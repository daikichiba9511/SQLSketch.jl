<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Design · SQLSketch.jl</title><meta name="title" content="Design · SQLSketch.jl"/><meta property="og:title" content="Design · SQLSketch.jl"/><meta property="twitter:title" content="Design · SQLSketch.jl"/><meta name="description" content="Documentation for SQLSketch.jl."/><meta property="og:description" content="Documentation for SQLSketch.jl."/><meta property="twitter:description" content="Documentation for SQLSketch.jl."/><meta property="og:url" content="https://daikichiba9511.github.io/SQLSketch.jl/design/"/><meta property="twitter:url" content="https://daikichiba9511.github.io/SQLSketch.jl/design/"/><link rel="canonical" href="https://daikichiba9511.github.io/SQLSketch.jl/design/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SQLSketch.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../api/">API Reference</a></li><li class="is-active"><a class="tocitem" href>Design</a><ul class="internal"><li><a class="tocitem" href="#1.-Purpose"><span>1. Purpose</span></a></li><li><a class="tocitem" href="#2.-Design-Goals"><span>2. Design Goals</span></a></li><li><a class="tocitem" href="#3.-Non-Goals"><span>3. Non-Goals</span></a></li><li><a class="tocitem" href="#4.-High-Level-Architecture"><span>4. High-Level Architecture</span></a></li><li><a class="tocitem" href="#5.-Core-vs-Extras-Layer"><span>5. Core vs Extras Layer</span></a></li><li><a class="tocitem" href="#6.-Query-Model"><span>6. Query Model</span></a></li><li><a class="tocitem" href="#7.-SQL-Transparency"><span>7. SQL Transparency</span></a></li><li><a class="tocitem" href="#8.-Expression-Model"><span>8. Expression Model</span></a></li><li><a class="tocitem" href="#9.-Placeholder-Design"><span>9. Placeholder Design</span></a></li><li><a class="tocitem" href="#10.-Dialect-and-Driver-Abstraction"><span>10. Dialect and Driver Abstraction</span></a></li><li><a class="tocitem" href="#11.-Capability-System"><span>11. Capability System</span></a></li><li><a class="tocitem" href="#12.-Type-Conversion-and-CodecRegistry"><span>12. Type Conversion and CodecRegistry</span></a></li><li><a class="tocitem" href="#13.-Query-Execution-Model"><span>13. Query Execution Model</span></a></li><li><a class="tocitem" href="#14.-Transaction-Model"><span>14. Transaction Model</span></a></li><li><a class="tocitem" href="#15.-DDL-and-Migration-Design"><span>15. DDL and Migration Design</span></a></li><li><a class="tocitem" href="#16.-Observability"><span>16. Observability</span></a></li><li><a class="tocitem" href="#17.-Testing-Strategy"><span>17. Testing Strategy</span></a></li><li><a class="tocitem" href="#18.-Project-Positioning"><span>18. Project Positioning</span></a></li><li><a class="tocitem" href="#19.-Summary"><span>19. Summary</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Design</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Design</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/main/docs/src/design.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="SQLSketch.jl-–-Design-Document"><a class="docs-heading-anchor" href="#SQLSketch.jl-–-Design-Document">SQLSketch.jl – Design Document</a><a id="SQLSketch.jl-–-Design-Document-1"></a><a class="docs-heading-anchor-permalink" href="#SQLSketch.jl-–-Design-Document" title="Permalink"></a></h1><h2 id="1.-Purpose"><a class="docs-heading-anchor" href="#1.-Purpose">1. Purpose</a><a id="1.-Purpose-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Purpose" title="Permalink"></a></h2><p>SQLSketch.jl is an <strong>experimental (“toy”) project</strong> exploring the design of a typed, composable SQL query core in Julia.</p><p>This project intentionally avoids competing with fully featured ORM frameworks. Instead, it focuses on:</p><ul><li>exploring design trade-offs,</li><li>clarifying abstraction boundaries,</li><li>and validating architectural ideas in a small but realistic setting.</li></ul><p>The code is serious; the positioning is not.</p><hr/><h2 id="2.-Design-Goals"><a class="docs-heading-anchor" href="#2.-Design-Goals">2. Design Goals</a><a id="2.-Design-Goals-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Design-Goals" title="Permalink"></a></h2><ul><li>SQL is always visible and inspectable</li><li>Query APIs follow SQL&#39;s <em>logical evaluation order</em></li><li>Output SQL follows SQL&#39;s <em>syntactic order</em></li><li>Strong typing at query boundaries</li><li>Minimal hidden magic</li><li>Clear separation between core primitives and convenience layers</li><li><strong>PostgreSQL-first development</strong> with SQLite / MySQL compatibility</li></ul><hr/><h2 id="3.-Non-Goals"><a class="docs-heading-anchor" href="#3.-Non-Goals">3. Non-Goals</a><a id="3.-Non-Goals-1"></a><a class="docs-heading-anchor-permalink" href="#3.-Non-Goals" title="Permalink"></a></h2><ul><li>Replacing mature ORMs</li><li>Hiding SQL completely</li><li>Automatic schema diff or online migrations</li><li>Full ActiveRecord-style relations</li><li>Becoming a “standard” Julia DB abstraction</li></ul><hr/><h2 id="4.-High-Level-Architecture"><a class="docs-heading-anchor" href="#4.-High-Level-Architecture">4. High-Level Architecture</a><a id="4.-High-Level-Architecture-1"></a><a class="docs-heading-anchor-permalink" href="#4.-High-Level-Architecture" title="Permalink"></a></h2><pre><code class="nohighlight hljs">┌─────────────────────────────────────────────────────────────────┐
│                         Application                             │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                   Extras Layer (optional)                       │
├─────────────────────────────────────────────────────────────────┤
│  • Migration runner (apply_migrations, migration_status)        │
│  • Placeholder syntax (p_)                                      │
│  • Future: Repository patterns, CRUD helpers, Schema macros     │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│              Core Layer (SQLSketch.Core)                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Expression AST ──┐                                             │
│                   │                                             │
│                   ▼                                             │
│              Query AST ──► SQL Compilation ──► Execute ──► Map  │
│                                     │              │         │  │
│                                     │              │         │  │
│                           Dialect ──┘     Driver ──┘         │  │
│                                                              │  │
│                                            CodecRegistry ────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘</code></pre><h2 id="5.-Core-vs-Extras-Layer"><a class="docs-heading-anchor" href="#5.-Core-vs-Extras-Layer">5. Core vs Extras Layer</a><a id="5.-Core-vs-Extras-Layer-1"></a><a class="docs-heading-anchor-permalink" href="#5.-Core-vs-Extras-Layer" title="Permalink"></a></h2><p>SQLSketch.jl is intentionally designed as a <strong>two-layer system</strong>:</p><ul><li>a small, stable <strong>Core layer</strong></li><li>an optional, disposable <strong>Extras layer</strong></li></ul><p>This separation is fundamental to the project&#39;s goals.</p><hr/><h3 id="5.1-Core-Layer"><a class="docs-heading-anchor" href="#5.1-Core-Layer">5.1 Core Layer</a><a id="5.1-Core-Layer-1"></a><a class="docs-heading-anchor-permalink" href="#5.1-Core-Layer" title="Permalink"></a></h3><p>The Core layer defines the <strong>essential primitives</strong> required to build, compile, and execute SQL queries in a principled and inspectable way.</p><p>The Core layer is designed to be:</p><ul><li>minimal</li><li>explicit</li><li>stable over time</li><li>independent of application-specific patterns</li></ul><h4 id="Core-Responsibilities"><a class="docs-heading-anchor" href="#Core-Responsibilities">Core Responsibilities</a><a id="Core-Responsibilities-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Responsibilities" title="Permalink"></a></h4><p>The Core layer is responsible for:</p><ul><li>Query and Expression AST</li><li>SQL compilation</li><li>Dialect abstraction (PostgreSQL / MySQL / SQLite)</li><li>Driver abstraction (connection, execution, transactions)</li><li>Parameter binding</li><li>Row decoding and mapping</li><li>Transaction management</li><li>Error normalization</li><li>Observability hooks (logging / tracing)</li></ul><p>The Core layer <strong>does not</strong> attempt to provide a full ORM experience.</p><hr/><h3 id="5.2-Extras-Layer"><a class="docs-heading-anchor" href="#5.2-Extras-Layer">5.2 Extras Layer</a><a id="5.2-Extras-Layer-1"></a><a class="docs-heading-anchor-permalink" href="#5.2-Extras-Layer" title="Permalink"></a></h3><p>The Extras layer provides <strong>convenience abstractions</strong> built on top of the Core.</p><p>It exists to improve ergonomics, not to redefine semantics.</p><p>The Extras layer is explicitly considered <strong>optional and replaceable</strong>.</p><h4 id="Extras-Layer-Responsibilities"><a class="docs-heading-anchor" href="#Extras-Layer-Responsibilities">Extras Layer Responsibilities</a><a id="Extras-Layer-Responsibilities-1"></a><a class="docs-heading-anchor-permalink" href="#Extras-Layer-Responsibilities" title="Permalink"></a></h4><p>Typical responsibilities of the Extras layer include:</p><ul><li>Repository patterns</li><li>CRUD helpers</li><li>Relation handling and preloading</li><li>Schema definition macros</li><li>DDL generation and diffing</li><li>Validation-related sugar</li><li>Migration application (runner)</li></ul><p>All Extras-layer features must be expressible <strong>purely in terms of Core APIs</strong>.</p><hr/><h3 id="5.3-Design-Rationale"><a class="docs-heading-anchor" href="#5.3-Design-Rationale">5.3 Design Rationale</a><a id="5.3-Design-Rationale-1"></a><a class="docs-heading-anchor-permalink" href="#5.3-Design-Rationale" title="Permalink"></a></h3><p>This separation allows SQLSketch.jl to:</p><ul><li>avoid over-committing to a single ORM style</li><li>remain useful for both applications and data workflows</li><li>keep the Core small enough to reason about</li><li>experiment with higher-level abstractions without breaking the foundation</li></ul><p>In other words:</p><blockquote><p><strong>Core defines &quot;what is possible&quot;; Extras defines &quot;what is convenient&quot;.</strong></p></blockquote><hr/><h3 id="5.4-Stability-Contract"><a class="docs-heading-anchor" href="#5.4-Stability-Contract">5.4 Stability Contract</a><a id="5.4-Stability-Contract-1"></a><a class="docs-heading-anchor-permalink" href="#5.4-Stability-Contract" title="Permalink"></a></h3><p>The Core layer is expected to be:</p><ul><li>backward-compatible within reason</li><li>conservative in API changes</li><li>explicit about breaking changes</li></ul><p>The Extras layer is free to evolve, change, or even be rewritten entirely.</p><p>This contract allows SQLSketch.jl to serve as a long-lived design exploration without locking users into premature abstractions.</p><h2 id="6.-Query-Model"><a class="docs-heading-anchor" href="#6.-Query-Model">6. Query Model</a><a id="6.-Query-Model-1"></a><a class="docs-heading-anchor-permalink" href="#6.-Query-Model" title="Permalink"></a></h2><p>At the heart of SQLSketch.jl is a <strong>typed query model</strong> built around explicit structure and predictable transformations.</p><p>Rather than hiding SQL behind opaque abstractions, the query model mirrors SQL semantics while remaining composable and inspectable.</p><hr/><h3 id="6.1-Logical-Pipeline-API"><a class="docs-heading-anchor" href="#6.1-Logical-Pipeline-API">6.1 Logical Pipeline API</a><a id="6.1-Logical-Pipeline-API-1"></a><a class="docs-heading-anchor-permalink" href="#6.1-Logical-Pipeline-API" title="Permalink"></a></h3><p>Query construction follows <strong>SQL’s logical evaluation order</strong>, not its syntactic order.</p><p>The logical order is:</p><pre><code class="nohighlight hljs">FROM → JOIN → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT</code></pre><p>In SQLSketch.jl, queries are constructed as a pipeline reflecting this order.</p><h4 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h4><pre><code class="language-julia hljs">q = from(:users) |&gt;
    where(col(:users, :active) == literal(true)) |&gt;
    order_by(col(:users, :created_at); desc=true) |&gt;
    limit(10) |&gt;
    select(UserDTO, col(:users, :id), col(:users, :email))</code></pre><p>Internally, the query is represented as an AST. When compiled, it is emitted as syntactically correct SQL:</p><pre><code class="language-sql hljs">SELECT &quot;users&quot;.&quot;id&quot;, &quot;users&quot;.&quot;email&quot;
FROM &quot;users&quot;
WHERE &quot;users&quot;.&quot;active&quot; = $1
ORDER BY &quot;users&quot;.&quot;created_at&quot; DESC
LIMIT 10</code></pre><hr/><h3 id="6.2-Shape-Preserving-vs-Shape-Changing-Operations"><a class="docs-heading-anchor" href="#6.2-Shape-Preserving-vs-Shape-Changing-Operations">6.2 Shape-Preserving vs Shape-Changing Operations</a><a id="6.2-Shape-Preserving-vs-Shape-Changing-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#6.2-Shape-Preserving-vs-Shape-Changing-Operations" title="Permalink"></a></h3><p>A key design rule in SQLSketch.jl is that <strong>most query operations preserve the output shape</strong>.</p><h4 id="Shape-Preserving-Operations"><a class="docs-heading-anchor" href="#Shape-Preserving-Operations">Shape-Preserving Operations</a><a id="Shape-Preserving-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Shape-Preserving-Operations" title="Permalink"></a></h4><p>The following operations do <strong>not</strong> change the query’s output type:</p><ul><li><code>from</code></li><li><code>join</code></li><li><code>where</code></li><li><code>group_by</code></li><li><code>having</code></li><li><code>order_by</code></li><li><code>limit</code></li><li><code>offset</code></li><li><code>distinct</code></li></ul><p>These operations refine <em>which rows</em> are returned, not <em>what a row looks like</em>.</p><hr/><h3 id="6.3-The-Role-of-select"><a class="docs-heading-anchor" href="#6.3-The-Role-of-select">6.3 The Role of <code>select</code></a><a id="6.3-The-Role-of-select-1"></a><a class="docs-heading-anchor-permalink" href="#6.3-The-Role-of-select" title="Permalink"></a></h3><p>The <code>select</code> operation is the <strong>only operation allowed to change the output type</strong> of a query.</p><p>This rule provides:</p><ul><li>predictable type flow</li><li>easier reasoning about query transformations</li><li>a clear boundary for data shaping</li></ul><h4 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h4><p>Selecting into a struct:</p><pre><code class="language-julia hljs">q |&gt; select(UserDTO, col(:users, :id), col(:users, :email))</code></pre><p>Selecting into a <code>NamedTuple</code>:</p><pre><code class="language-julia hljs">q |&gt; select(NamedTuple, col(:users, :id), col(:users, :email))</code></pre><hr/><h3 id="6.4-Output-Type-(OutT)"><a class="docs-heading-anchor" href="#6.4-Output-Type-(OutT)">6.4 Output Type (<code>OutT</code>)</a><a id="6.4-Output-Type-(OutT)-1"></a><a class="docs-heading-anchor-permalink" href="#6.4-Output-Type-(OutT)" title="Permalink"></a></h3><p>Each query is parameterized by an output type:</p><pre><code class="nohighlight hljs">Select{OutT}</code></pre><p>The output type determines:</p><ul><li>how rows are decoded</li><li>how validation is applied (if any)</li><li>what the user receives from <code>fetch_all</code>, <code>fetch_one</code>, or <code>fetch_maybe</code></li></ul><p>The Core layer treats <code>OutT</code> as an opaque type and relies on constructors and codecs to enforce invariants.</p><hr/><h3 id="6.5-Joins-and-Composite-Results"><a class="docs-heading-anchor" href="#6.5-Joins-and-Composite-Results">6.5 Joins and Composite Results</a><a id="6.5-Joins-and-Composite-Results-1"></a><a class="docs-heading-anchor-permalink" href="#6.5-Joins-and-Composite-Results" title="Permalink"></a></h3><p>JOIN operations combine multiple row sources.</p><p>By default, join results are represented as <code>NamedTuple</code> values, preserving all columns explicitly.</p><p>Example:</p><pre><code class="language-julia hljs">from(:users) |&gt;
    join(:orders, col(:users, :id) == col(:orders, :user_id); kind=:inner)</code></pre><p>This produces rows as <code>NamedTuple</code> values with all columns from both tables.</p><p>Mapping into a domain-specific type requires an explicit <code>select</code>.</p><hr/><h3 id="6.6-Rationale"><a class="docs-heading-anchor" href="#6.6-Rationale">6.6 Rationale</a><a id="6.6-Rationale-1"></a><a class="docs-heading-anchor-permalink" href="#6.6-Rationale" title="Permalink"></a></h3><p>This query model intentionally avoids:</p><ul><li>implicit projections</li><li>automatic relation materialization</li><li>silent type changes</li></ul><p>Instead, it favors <strong>explicitness and local reasoning</strong>.</p><p>By constraining when and how the output type changes, SQLSketch.jl makes complex queries easier to understand, refactor, and debug.</p><h2 id="7.-SQL-Transparency"><a class="docs-heading-anchor" href="#7.-SQL-Transparency">7. SQL Transparency</a><a id="7.-SQL-Transparency-1"></a><a class="docs-heading-anchor-permalink" href="#7.-SQL-Transparency" title="Permalink"></a></h2><p>A core principle of SQLSketch.jl is that <strong>SQL is never hidden</strong>.</p><p>The library treats SQL as a first-class artifact that users are encouraged to inspect, reason about, and debug.</p><hr/><h3 id="7.1-Inspectable-SQL"><a class="docs-heading-anchor" href="#7.1-Inspectable-SQL">7.1 Inspectable SQL</a><a id="7.1-Inspectable-SQL-1"></a><a class="docs-heading-anchor-permalink" href="#7.1-Inspectable-SQL" title="Permalink"></a></h3><p>Every query can be inspected before execution.</p><p>SQLSketch.jl provides APIs such as:</p><ul><li><code>sql(query)</code> – return the generated SQL string</li><li><code>compile(query)</code> – return SQL together with parameter ordering</li><li><code>explain(query)</code> – generate an EXPLAIN statement (if supported)</li></ul><p>This design ensures that users are never forced to guess what SQL is actually being executed.</p><hr/><h3 id="7.2-Observability-Oriented-Design"><a class="docs-heading-anchor" href="#7.2-Observability-Oriented-Design">7.2 Observability-Oriented Design</a><a id="7.2-Observability-Oriented-Design-1"></a><a class="docs-heading-anchor-permalink" href="#7.2-Observability-Oriented-Design" title="Permalink"></a></h3><p>SQL transparency is also reflected in observability features.</p><p>The Core layer supports query hooks that receive:</p><ul><li>raw SQL</li><li>parameter metadata</li><li>execution timing</li><li>row counts (when available)</li><li>execution errors</li></ul><p>This enables straightforward integration with logging, tracing, and metrics systems without patching internals.</p><hr/><h2 id="8.-Expression-Model"><a class="docs-heading-anchor" href="#8.-Expression-Model">8. Expression Model</a><a id="8.-Expression-Model-1"></a><a class="docs-heading-anchor-permalink" href="#8.-Expression-Model" title="Permalink"></a></h2><p>SQLSketch.jl represents SQL conditions and expressions explicitly using an <strong>Expression AST</strong>.</p><p>Expressions are not strings. They are structured values that can be inspected, transformed, and compiled in a dialect-aware manner.</p><hr/><h3 id="8.1-Expression-AST"><a class="docs-heading-anchor" href="#8.1-Expression-AST">8.1 Expression AST</a><a id="8.1-Expression-AST-1"></a><a class="docs-heading-anchor-permalink" href="#8.1-Expression-AST" title="Permalink"></a></h3><p>Examples of expression nodes include:</p><ul><li>column references</li><li>literal values</li><li>bound parameters</li><li>binary operators (<code>=</code>, <code>&lt;</code>, <code>AND</code>, <code>OR</code>, etc.)</li><li>unary operators (<code>NOT</code>, <code>IS NULL</code>, etc.)</li><li>subquery expressions (<code>IN</code>, <code>EXISTS</code>)</li></ul><p>Expressions form trees that are embedded into query AST nodes such as <code>WHERE</code>, <code>ON</code>, or <code>HAVING</code>.</p><hr/><h3 id="8.2-Explicit-Expressions"><a class="docs-heading-anchor" href="#8.2-Explicit-Expressions">8.2 Explicit Expressions</a><a id="8.2-Explicit-Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#8.2-Explicit-Expressions" title="Permalink"></a></h3><p>The Core API always allows expressions to be specified explicitly.</p><p>Example:</p><pre><code class="language-julia hljs">where(q, col(:users, :email) == param(String, :email))</code></pre><p>This form is unambiguous and works uniformly across all query shapes, including joins, subqueries, and correlated queries.</p><hr/><h2 id="9.-Placeholder-Design"><a class="docs-heading-anchor" href="#9.-Placeholder-Design">9. Placeholder Design</a><a id="9.-Placeholder-Design-1"></a><a class="docs-heading-anchor-permalink" href="#9.-Placeholder-Design" title="Permalink"></a></h2><p>To improve ergonomics, SQLSketch.jl optionally supports placeholder-based expression construction.</p><p>However, placeholders are <strong>never required</strong> by the Core layer.</p><hr/><h3 id="9.1-Optional-Placeholder-(p_)"><a class="docs-heading-anchor" href="#9.1-Optional-Placeholder-(p_)">9.1 Optional Placeholder (<code>p_</code>)</a><a id="9.1-Optional-Placeholder-(p_)-1"></a><a class="docs-heading-anchor-permalink" href="#9.1-Optional-Placeholder-(p_)" title="Permalink"></a></h3><p>The <code>p_</code> placeholder function provides syntactic sugar for parameters:</p><pre><code class="language-julia hljs"># Using placeholder
email_param = p_(:email, String)
q = from(:users) |&gt;
    where(col(:users, :email) == email_param)

# Execute with parameter value
fetch_one(conn, q, email_param =&gt; &quot;alice@example.com&quot;)</code></pre><p>This is equivalent to the explicit form:</p><pre><code class="language-julia hljs">q = from(:users) |&gt;
    where(col(:users, :email) == param(String, :email))</code></pre><hr/><h3 id="9.2-Why-Placeholders-Are-Optional"><a class="docs-heading-anchor" href="#9.2-Why-Placeholders-Are-Optional">9.2 Why Placeholders Are Optional</a><a id="9.2-Why-Placeholders-Are-Optional-1"></a><a class="docs-heading-anchor-permalink" href="#9.2-Why-Placeholders-Are-Optional" title="Permalink"></a></h3><p>Placeholders are not mandatory for several reasons:</p><ul><li>they can become ambiguous in multi-join queries</li><li>they add indirection during debugging</li><li>they complicate core API contracts</li></ul><p>For these reasons:</p><ul><li>the Core layer always accepts explicit expressions</li><li>placeholder-based syntax is treated as optional sugar</li><li>both styles can coexist in the same codebase</li></ul><hr/><h3 id="9.3-Design-Rationale"><a class="docs-heading-anchor" href="#9.3-Design-Rationale">9.3 Design Rationale</a><a id="9.3-Design-Rationale-1"></a><a class="docs-heading-anchor-permalink" href="#9.3-Design-Rationale" title="Permalink"></a></h3><p>By separating <strong>expression semantics</strong> from <strong>expression syntax</strong>, SQLSketch.jl achieves the following:</p><ul><li>the Core remains small and explicit</li><li>ergonomics can evolve independently</li><li>advanced queries remain readable and debuggable</li></ul><p>This approach balances usability with long-term maintainability.</p><h2 id="10.-Dialect-and-Driver-Abstraction"><a class="docs-heading-anchor" href="#10.-Dialect-and-Driver-Abstraction">10. Dialect and Driver Abstraction</a><a id="10.-Dialect-and-Driver-Abstraction-1"></a><a class="docs-heading-anchor-permalink" href="#10.-Dialect-and-Driver-Abstraction" title="Permalink"></a></h2><p>SQLSketch.jl explicitly separates <strong>what SQL is generated</strong> from <strong>how SQL is executed</strong>.</p><p>This separation is achieved through two orthogonal abstractions:</p><ul><li><strong>Dialect</strong>: SQL generation and database semantics</li><li><strong>Driver</strong>: connection management and execution</li></ul><hr/><h3 id="10.1-Dialect"><a class="docs-heading-anchor" href="#10.1-Dialect">10.1 Dialect</a><a id="10.1-Dialect-1"></a><a class="docs-heading-anchor-permalink" href="#10.1-Dialect" title="Permalink"></a></h3><p>A Dialect represents a database’s SQL syntax and semantic differences.</p><p>Each supported database provides its own Dialect implementation (e.g. SQLite, PostgreSQL, MySQL).</p><h4 id="Dialect-Responsibilities"><a class="docs-heading-anchor" href="#Dialect-Responsibilities">Dialect Responsibilities</a><a id="Dialect-Responsibilities-1"></a><a class="docs-heading-anchor-permalink" href="#Dialect-Responsibilities" title="Permalink"></a></h4><p>A Dialect is responsible for:</p><ul><li>generating SQL strings from query ASTs</li><li>quoting identifiers (tables, columns, aliases)</li><li>defining placeholder syntax (<code>?</code>, <code>$1</code>, etc.)</li><li>compiling DDL statements</li><li>reporting supported features via capabilities</li></ul><p>Dialect implementations are <strong>pure</strong>: they do not manage connections or execute SQL.</p><hr/><h3 id="10.2-Driver"><a class="docs-heading-anchor" href="#10.2-Driver">10.2 Driver</a><a id="10.2-Driver-1"></a><a class="docs-heading-anchor-permalink" href="#10.2-Driver" title="Permalink"></a></h3><p>A Driver represents the execution layer for a specific database backend.</p><p>Drivers handle all interactions with the underlying database client (e.g. DBInterface, libpq, mysqlclient).</p><h4 id="Driver-Responsibilities"><a class="docs-heading-anchor" href="#Driver-Responsibilities">Driver Responsibilities</a><a id="Driver-Responsibilities-1"></a><a class="docs-heading-anchor-permalink" href="#Driver-Responsibilities" title="Permalink"></a></h4><p>A Driver is responsible for:</p><ul><li>opening and closing connections</li><li>preparing statements</li><li>executing SQL statements</li><li>binding parameters</li><li>managing transactions</li><li>handling cancellation and timeouts (if supported)</li></ul><p>Drivers do <strong>not</strong> interpret query semantics or perform type conversion.</p><hr/><h3 id="10.3-Why-Separate-Dialect-and-Driver"><a class="docs-heading-anchor" href="#10.3-Why-Separate-Dialect-and-Driver">10.3 Why Separate Dialect and Driver</a><a id="10.3-Why-Separate-Dialect-and-Driver-1"></a><a class="docs-heading-anchor-permalink" href="#10.3-Why-Separate-Dialect-and-Driver" title="Permalink"></a></h3><p>Separating Dialect and Driver provides several benefits:</p><ul><li>SQL generation can be tested without a database</li><li>multiple drivers can share a dialect</li><li>dialect logic remains independent of client libraries</li><li>feature differences are made explicit</li></ul><p>This design avoids conflating SQL semantics with execution mechanics.</p><hr/><h2 id="11.-Capability-System"><a class="docs-heading-anchor" href="#11.-Capability-System">11. Capability System</a><a id="11.-Capability-System-1"></a><a class="docs-heading-anchor-permalink" href="#11.-Capability-System" title="Permalink"></a></h2><p>Database systems differ in supported features and behavior. SQLSketch.jl makes these differences explicit using a <strong>capability system</strong>.</p><hr/><h3 id="11.1-Capabilities"><a class="docs-heading-anchor" href="#11.1-Capabilities">11.1 Capabilities</a><a id="11.1-Capabilities-1"></a><a class="docs-heading-anchor-permalink" href="#11.1-Capabilities" title="Permalink"></a></h3><p>Capabilities describe optional database features, such as:</p><ul><li>Common Table Expressions (CTE)</li><li><code>RETURNING</code> clauses</li><li><code>UPSERT</code> / <code>ON CONFLICT</code></li><li>window functions</li><li>bulk copy operations</li><li>statement cancellation</li><li>savepoints</li></ul><p>Each Dialect reports which capabilities it supports.</p><hr/><h3 id="11.2-Capability-Based-Behavior"><a class="docs-heading-anchor" href="#11.2-Capability-Based-Behavior">11.2 Capability-Based Behavior</a><a id="11.2-Capability-Based-Behavior-1"></a><a class="docs-heading-anchor-permalink" href="#11.2-Capability-Based-Behavior" title="Permalink"></a></h3><p>Capabilities influence behavior in two primary ways:</p><ol><li><p><strong>Early failure</strong> If a query requires an unsupported capability, compilation fails with a clear error.</p></li><li><p><strong>Graceful degradation</strong> When possible, a Dialect may emit an alternative SQL formulation that avoids the unsupported feature.</p></li></ol><p>This ensures that feature differences are visible and intentional.</p><hr/><h3 id="11.3-Database-Specific-Extensions"><a class="docs-heading-anchor" href="#11.3-Database-Specific-Extensions">11.3 Database-Specific Extensions</a><a id="11.3-Database-Specific-Extensions-1"></a><a class="docs-heading-anchor-permalink" href="#11.3-Database-Specific-Extensions" title="Permalink"></a></h3><p>Some features are inherently database-specific.</p><p>Rather than forcing these into the Core API, SQLSketch.jl treats them as <strong>explicit extensions</strong> guarded by capability checks.</p><p>Example (conceptual):</p><pre><code class="language-julia hljs"># Hypothetical PostgreSQL COPY FROM support
if supports(dialect, CAP_BULK_COPY)
    bulk_copy_from(conn, :table, source)
else
    error(&quot;BULK COPY is not supported by this database&quot;)
end</code></pre><p>This approach keeps the Core API minimal while still allowing advanced database-specific functionality.</p><hr/><h3 id="11.4-Rationale"><a class="docs-heading-anchor" href="#11.4-Rationale">11.4 Rationale</a><a id="11.4-Rationale-1"></a><a class="docs-heading-anchor-permalink" href="#11.4-Rationale" title="Permalink"></a></h3><p>By combining Dialect abstraction with an explicit capability system, SQLSketch.jl achieves:</p><ul><li>predictable cross-database behavior</li><li>clear visibility into feature differences</li><li>a stable foundation for experimentation</li><li>a clean boundary between portable and non-portable code</li></ul><p>This design avoids both lowest-common-denominator APIs and accidental reliance on database-specific behavior.</p><h2 id="12.-Type-Conversion-and-CodecRegistry"><a class="docs-heading-anchor" href="#12.-Type-Conversion-and-CodecRegistry">12. Type Conversion and CodecRegistry</a><a id="12.-Type-Conversion-and-CodecRegistry-1"></a><a class="docs-heading-anchor-permalink" href="#12.-Type-Conversion-and-CodecRegistry" title="Permalink"></a></h2><p>SQLSketch.jl centralizes all database-to-Julia type conversion in a dedicated component called <strong>CodecRegistry</strong>.</p><p>This design explicitly separates:</p><ul><li>SQL semantics (Dialect)</li><li>execution mechanics (Driver)</li><li><strong>data representation and invariants (CodecRegistry)</strong></li></ul><hr/><h3 id="12.1-Motivation"><a class="docs-heading-anchor" href="#12.1-Motivation">12.1 Motivation</a><a id="12.1-Motivation-1"></a><a class="docs-heading-anchor-permalink" href="#12.1-Motivation" title="Permalink"></a></h3><p>Databases and Julia have fundamentally different type systems.</p><p>Examples include:</p><ul><li>NULL handling</li><li>UUID representation</li><li>Date / DateTime precision</li><li>JSON storage formats</li><li>SQLite’s dynamic typing</li></ul><p>If handled implicitly, these differences quickly lead to inconsistent behavior and subtle bugs.</p><p>SQLSketch.jl addresses this by making type conversion <strong>explicit and centralized</strong>.</p><hr/><h3 id="12.2-CodecRegistry"><a class="docs-heading-anchor" href="#12.2-CodecRegistry">12.2 CodecRegistry</a><a id="12.2-CodecRegistry-1"></a><a class="docs-heading-anchor-permalink" href="#12.2-CodecRegistry" title="Permalink"></a></h3><p>The CodecRegistry defines how values are:</p><ul><li>encoded before being sent to the database</li><li>decoded when read from the database</li></ul><p>Each Julia type that participates in queries or result mapping is associated with a codec.</p><p>Responsibilities of CodecRegistry include:</p><ul><li>encoding Julia values into database-compatible representations</li><li>decoding database values into Julia types</li><li>enforcing a consistent NULL policy</li><li>normalizing backend-specific quirks</li></ul><hr/><h3 id="12.3-NULL-Policy"><a class="docs-heading-anchor" href="#12.3-NULL-Policy">12.3 NULL Policy</a><a id="12.3-NULL-Policy-1"></a><a class="docs-heading-anchor-permalink" href="#12.3-NULL-Policy" title="Permalink"></a></h3><p>NULL handling is a global policy decision.</p><p>SQLSketch.jl supports configurable NULL policies, such as:</p><ul><li><code>Missing</code>-based representation (recommended)</li><li><code>Nothing</code>-based representation</li></ul><p>The chosen policy is applied consistently across:</p><ul><li>query parameters</li><li>result decoding</li><li>struct construction</li></ul><p>This avoids mixing NULL semantics within a single application.</p><hr/><h3 id="12.4-Database-Specific-Type-Handling"><a class="docs-heading-anchor" href="#12.4-Database-Specific-Type-Handling">12.4 Database-Specific Type Handling</a><a id="12.4-Database-Specific-Type-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#12.4-Database-Specific-Type-Handling" title="Permalink"></a></h3><h4 id="PostgreSQL-(Primary-Target)"><a class="docs-heading-anchor" href="#PostgreSQL-(Primary-Target)">PostgreSQL (Primary Target)</a><a id="PostgreSQL-(Primary-Target)-1"></a><a class="docs-heading-anchor-permalink" href="#PostgreSQL-(Primary-Target)" title="Permalink"></a></h4><p>PostgreSQL is the primary development target with rich native type support:</p><ul><li>Native UUID type</li><li>JSONB for structured data</li><li>Precise timestamp handling with timezone support</li><li>Arrays and composite types</li><li>Full ACID compliance with strict type checking</li></ul><h4 id="SQLite-(Development-and-Testing)"><a class="docs-heading-anchor" href="#SQLite-(Development-and-Testing)">SQLite (Development and Testing)</a><a id="SQLite-(Development-and-Testing)-1"></a><a class="docs-heading-anchor-permalink" href="#SQLite-(Development-and-Testing)" title="Permalink"></a></h4><p>SQLite is supported as a lightweight backend for local development and testing.</p><p>Because SQLite is dynamically typed, the CodecRegistry plays a critical role in enforcing invariants to maintain PostgreSQL compatibility.</p><p>Examples include:</p><ul><li>representing UUIDs as TEXT (PostgreSQL uses native UUID)</li><li>normalizing DateTime values (PostgreSQL has precise TIMESTAMP WITH TIME ZONE)</li><li>enforcing boolean semantics (PostgreSQL has native BOOLEAN)</li><li>validating decoded values before struct construction</li></ul><p>This ensures that SQLite-based testing remains meaningful and compatible with PostgreSQL production deployments.</p><hr/><h2 id="13.-Query-Execution-Model"><a class="docs-heading-anchor" href="#13.-Query-Execution-Model">13. Query Execution Model</a><a id="13.-Query-Execution-Model-1"></a><a class="docs-heading-anchor-permalink" href="#13.-Query-Execution-Model" title="Permalink"></a></h2><p>SQLSketch.jl provides a clear separation between <strong>side-effecting operations</strong> and <strong>data retrieval operations</strong>.</p><p>This distinction is fundamental to the execution API design.</p><hr/><h3 id="13.1-Execute-vs-Fetch"><a class="docs-heading-anchor" href="#13.1-Execute-vs-Fetch">13.1 Execute vs Fetch</a><a id="13.1-Execute-vs-Fetch-1"></a><a class="docs-heading-anchor-permalink" href="#13.1-Execute-vs-Fetch" title="Permalink"></a></h3><p>The execution layer provides two categories of functions:</p><h4 id="execute-Side-Effects-Only"><a class="docs-heading-anchor" href="#execute-Side-Effects-Only"><code>execute</code> - Side Effects Only</a><a id="execute-Side-Effects-Only-1"></a><a class="docs-heading-anchor-permalink" href="#execute-Side-Effects-Only" title="Permalink"></a></h4><pre><code class="language-julia hljs">execute(conn, query) -&gt; Int64</code></pre><p><strong>Purpose</strong>: Execute SQL statements that produce <strong>side effects</strong> but do not return data.</p><p><strong>Returns</strong>: Number of affected rows (for DML) or 0 (for DDL).</p><p><strong>Use cases</strong>:</p><ul><li><code>INSERT</code> without <code>RETURNING</code></li><li><code>UPDATE</code> without <code>RETURNING</code></li><li><code>DELETE</code> without <code>RETURNING</code></li><li><code>CREATE TABLE</code>, <code>ALTER TABLE</code>, <code>DROP TABLE</code></li><li><code>CREATE INDEX</code>, <code>DROP INDEX</code></li></ul><p><strong>Example</strong>:</p><pre><code class="language-julia hljs"># Insert without retrieving data
q = insert_into(:users, [:email, :name]) |&gt;
    values([literal(&quot;alice@example.com&quot;), literal(&quot;Alice&quot;)])

rows_affected = execute(conn, q)
# → 1</code></pre><h4 id="fetch_*-Data-Retrieval"><a class="docs-heading-anchor" href="#fetch_*-Data-Retrieval"><code>fetch_*</code> - Data Retrieval</a><a id="fetch_*-Data-Retrieval-1"></a><a class="docs-heading-anchor-permalink" href="#fetch_*-Data-Retrieval" title="Permalink"></a></h4><pre><code class="language-julia hljs">fetch_all(conn, query, T) -&gt; Vector{T}
fetch_one(conn, query, T) -&gt; T
fetch_maybe(conn, query, T) -&gt; Union{T, Nothing}</code></pre><p><strong>Purpose</strong>: Execute SQL statements that <strong>return data</strong>.</p><p><strong>Returns</strong>: Decoded rows as Julia values (structs, NamedTuples, etc.)</p><p><strong>Use cases</strong>:</p><ul><li><code>SELECT</code> queries</li><li><code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code> with <code>RETURNING</code></li></ul><p><strong>Example</strong>:</p><pre><code class="language-julia hljs"># Retrieve data
q = from(:users) |&gt;
    where(col(:users, :active) == literal(true)) |&gt;
    select(NamedTuple, col(:users, :id), col(:users, :email))

users = fetch_all(conn, q, NamedTuple)
# → [{id: 1, email: &quot;alice@example.com&quot;}, ...]

# Insert with RETURNING
q = insert_into(:users, [:email, :name]) |&gt;
    values([literal(&quot;bob@example.com&quot;), literal(&quot;Bob&quot;)]) |&gt;
    returning(col(:users, :id))

user_id = fetch_one(conn, q, Int64)
# → 42</code></pre><hr/><h3 id="13.2-Design-Rationale"><a class="docs-heading-anchor" href="#13.2-Design-Rationale">13.2 Design Rationale</a><a id="13.2-Design-Rationale-1"></a><a class="docs-heading-anchor-permalink" href="#13.2-Design-Rationale" title="Permalink"></a></h3><p>This separation provides several benefits:</p><ol><li><p><strong>Intent clarity</strong>: The function name signals whether you expect data back.</p></li><li><p><strong>Type safety</strong>: <code>fetch_*</code> requires explicit result type, preventing type errors.</p></li><li><p><strong>Performance</strong>: <code>execute</code> can skip row decoding overhead.</p></li><li><p><strong>Error detection</strong>: Using <code>execute</code> on a <code>SELECT</code> or <code>fetch_*</code> on a <code>CREATE TABLE</code> makes the mistake obvious.</p></li></ol><hr/><h3 id="13.3-Unified-API"><a class="docs-heading-anchor" href="#13.3-Unified-API">13.3 Unified API</a><a id="13.3-Unified-API-1"></a><a class="docs-heading-anchor-permalink" href="#13.3-Unified-API" title="Permalink"></a></h3><p>Both <code>execute</code> and <code>fetch_*</code> accept the same connection types:</p><ul><li><code>Connection</code> (direct connection)</li><li><code>TransactionHandle</code> (within a transaction)</li><li><code>SavepointHandle</code> (within a savepoint)</li></ul><p>This means you can use the same code pattern regardless of transaction context:</p><pre><code class="language-julia hljs"># Direct execution
execute(conn, insert_query)

# Within transaction
transaction(conn) do tx
    execute(tx, insert_query)  # Same API
    users = fetch_all(tx, select_query, User)  # Same API
end</code></pre><hr/><h2 id="14.-Transaction-Model"><a class="docs-heading-anchor" href="#14.-Transaction-Model">14. Transaction Model</a><a id="14.-Transaction-Model-1"></a><a class="docs-heading-anchor-permalink" href="#14.-Transaction-Model" title="Permalink"></a></h2><p>Transaction handling is a <strong>Core responsibility</strong> in SQLSketch.jl.</p><p>Transactions are designed to be:</p><ul><li>explicit</li><li>composable</li><li>predictable</li><li>safe by default</li></ul><hr/><h3 id="14.1-Transaction-Semantics"><a class="docs-heading-anchor" href="#14.1-Transaction-Semantics">14.1 Transaction Semantics</a><a id="14.1-Transaction-Semantics-1"></a><a class="docs-heading-anchor-permalink" href="#14.1-Transaction-Semantics" title="Permalink"></a></h3><p>Transactions follow a simple and strict rule:</p><ul><li>if the transaction block completes normally → <strong>commit</strong></li><li>if an exception escapes the block → <strong>rollback</strong></li></ul><p>Example:</p><pre><code class="language-julia hljs">transaction(conn) do tx
    # Insert user
    insert_q = insert_into(:users, [:email, :name]) |&gt;
        values([literal(&quot;alice@example.com&quot;), literal(&quot;Alice&quot;)])
    execute(tx, insert_q)

    # Update settings
    update_q = update(:settings) |&gt;
        set(:theme, literal(&quot;dark&quot;)) |&gt;
        where(col(:settings, :user_id) == literal(1))
    execute(tx, update_q)
end</code></pre><p>If any operation inside the block fails, all changes are rolled back.</p><hr/><h3 id="14.2-Transaction-Handles"><a class="docs-heading-anchor" href="#14.2-Transaction-Handles">14.2 Transaction Handles</a><a id="14.2-Transaction-Handles-1"></a><a class="docs-heading-anchor-permalink" href="#14.2-Transaction-Handles" title="Permalink"></a></h3><p>Transaction handles are designed to be <strong>connection-compatible</strong>.</p><p>This means that within a transaction block:</p><ul><li>the same query execution APIs can be used</li><li>code does not need to distinguish between a connection and a transaction</li></ul><p>This simplifies application code and avoids branching logic.</p><hr/><h3 id="14.3-Isolation-and-Advanced-Features"><a class="docs-heading-anchor" href="#14.3-Isolation-and-Advanced-Features">14.3 Isolation and Advanced Features</a><a id="14.3-Isolation-and-Advanced-Features-1"></a><a class="docs-heading-anchor-permalink" href="#14.3-Isolation-and-Advanced-Features" title="Permalink"></a></h3><p>Transaction options such as:</p><ul><li>isolation level</li><li>read-only mode</li><li>savepoints</li></ul><p>are expressed explicitly and guarded by capabilities.</p><p>Unsupported options result in early, descriptive errors.</p><hr/><h3 id="14.4-Rationale"><a class="docs-heading-anchor" href="#14.4-Rationale">14.4 Rationale</a><a id="14.4-Rationale-1"></a><a class="docs-heading-anchor-permalink" href="#14.4-Rationale" title="Permalink"></a></h3><p>By keeping transaction semantics simple and explicit, SQLSketch.jl avoids:</p><ul><li>implicit nested transaction behavior</li><li>hidden auto-commit rules</li><li>backend-specific surprises</li></ul><p>The transaction model favors clarity and correctness over maximum flexibility, which aligns with the project’s experimental and educational goals.</p><h2 id="15.-DDL-and-Migration-Design"><a class="docs-heading-anchor" href="#15.-DDL-and-Migration-Design">15. DDL and Migration Design</a><a id="15.-DDL-and-Migration-Design-1"></a><a class="docs-heading-anchor-permalink" href="#15.-DDL-and-Migration-Design" title="Permalink"></a></h2><p>SQLSketch.jl treats schema management as a necessary but carefully scoped responsibility.</p><p>The goal is to support <strong>reliable schema evolution</strong> without turning the Core layer into a full schema-management framework.</p><hr/><h3 id="14.1-Scope-of-Responsibility"><a class="docs-heading-anchor" href="#14.1-Scope-of-Responsibility">14.1 Scope of Responsibility</a><a id="14.1-Scope-of-Responsibility-1"></a><a class="docs-heading-anchor-permalink" href="#14.1-Scope-of-Responsibility" title="Permalink"></a></h3><p>The Core layer is responsible for:</p><ul><li>applying migrations</li><li>tracking which migrations have been applied</li><li>compiling DDL statements in a dialect-aware way</li></ul><p>The Core layer explicitly does <strong>not</strong>:</p><ul><li>infer schema differences</li><li>auto-generate migrations</li><li>manage online or zero-downtime migrations</li></ul><p>These higher-level concerns are intentionally left to the Extras layer or external tooling.</p><hr/><h3 id="14.2-Migration-Runner"><a class="docs-heading-anchor" href="#14.2-Migration-Runner">14.2 Migration Runner</a><a id="14.2-Migration-Runner-1"></a><a class="docs-heading-anchor-permalink" href="#14.2-Migration-Runner" title="Permalink"></a></h3><p>SQLSketch.jl includes a minimal <strong>migration runner</strong>.</p><p>The runner’s responsibilities include:</p><ul><li>discovering migration files</li><li>applying migrations in a deterministic order</li><li>recording applied versions</li><li>preventing accidental re-application</li></ul><p>A dedicated metadata table (e.g. <code>schema_migrations</code>) is used to track applied migrations.</p><hr/><h3 id="14.3-Migration-Format"><a class="docs-heading-anchor" href="#14.3-Migration-Format">14.3 Migration Format</a><a id="14.3-Migration-Format-1"></a><a class="docs-heading-anchor-permalink" href="#14.3-Migration-Format" title="Permalink"></a></h3><p>Migrations may be expressed in one of the following forms:</p><ul><li>raw SQL files</li><li>structured DDL operations compiled by the Dialect</li></ul><p>The Core layer treats migrations as <strong>opaque units of change</strong>.</p><p>This allows users to:</p><ul><li>write database-specific SQL when needed</li><li>keep full control over schema evolution</li><li>avoid leaky abstractions in DDL generation</li></ul><hr/><h3 id="14.4-Dialect-Aware-DDL-Compilation"><a class="docs-heading-anchor" href="#14.4-Dialect-Aware-DDL-Compilation">14.4 Dialect-Aware DDL Compilation</a><a id="14.4-Dialect-Aware-DDL-Compilation-1"></a><a class="docs-heading-anchor-permalink" href="#14.4-Dialect-Aware-DDL-Compilation" title="Permalink"></a></h3><p>DDL statements are compiled through the Dialect abstraction.</p><p>This allows:</p><ul><li>correct identifier quoting</li><li>appropriate data type mapping</li><li>explicit handling of unsupported features</li></ul><p>If a DDL operation cannot be represented for a given Dialect, the system fails early with a descriptive error.</p><hr/><h3 id="14.5-Cross-Database-Migration-Support"><a class="docs-heading-anchor" href="#14.5-Cross-Database-Migration-Support">14.5 Cross-Database Migration Support</a><a id="14.5-Cross-Database-Migration-Support-1"></a><a class="docs-heading-anchor-permalink" href="#14.5-Cross-Database-Migration-Support" title="Permalink"></a></h3><h4 id="PostgreSQL-(Primary-Target)-2"><a class="docs-heading-anchor" href="#PostgreSQL-(Primary-Target)-2">PostgreSQL (Primary Target)</a><a class="docs-heading-anchor-permalink" href="#PostgreSQL-(Primary-Target)-2" title="Permalink"></a></h4><p>Migrations are primarily designed for PostgreSQL with full support for:</p><ul><li>Comprehensive constraint enforcement (CHECK, UNIQUE, FOREIGN KEY)</li><li>Rich data types (UUID, JSONB, arrays, timestamps with timezone)</li><li>Advanced features (partial indexes, exclusion constraints)</li></ul><h4 id="SQLite-(Development-and-Testing)-2"><a class="docs-heading-anchor" href="#SQLite-(Development-and-Testing)-2">SQLite (Development and Testing)</a><a class="docs-heading-anchor-permalink" href="#SQLite-(Development-and-Testing)-2" title="Permalink"></a></h4><p>SQLite is supported for local development and rapid iteration.</p><p>When applying the same migration set to SQLite, note that:</p><ul><li>SQLite may accept a broader range of schemas (more permissive)</li><li>Some constraints behave differently (e.g., FOREIGN KEY enforcement)</li><li>Runtime normalization is enforced via CodecRegistry to maintain PostgreSQL compatibility</li></ul><p>This approach enables:</p><ul><li>Fast local testing without PostgreSQL infrastructure</li><li>Early detection of schema issues before PostgreSQL deployment</li><li>Consistent migration files across development and production databases</li></ul><hr/><h3 id="14.6-Rationale"><a class="docs-heading-anchor" href="#14.6-Rationale">14.6 Rationale</a><a id="14.6-Rationale-1"></a><a class="docs-heading-anchor-permalink" href="#14.6-Rationale" title="Permalink"></a></h3><p>By limiting the Core’s responsibility to migration application, SQLSketch.jl avoids:</p><ul><li>overly complex schema DSLs</li><li>brittle diff-based migration generation</li><li>tight coupling between schema and query APIs</li></ul><p>This design keeps schema management explicit, inspectable, and aligned with the project’s exploratory nature.</p><h2 id="16.-Observability"><a class="docs-heading-anchor" href="#16.-Observability">16. Observability</a><a id="16.-Observability-1"></a><a class="docs-heading-anchor-permalink" href="#16.-Observability" title="Permalink"></a></h2><p>SQLSketch.jl is designed to make database interactions <strong>observable by default</strong>.</p><p>Rather than hiding execution details behind abstractions, the Core layer exposes hooks and inspection points that allow users to understand what is happening at runtime.</p><hr/><h3 id="15.1-Query-Hooks"><a class="docs-heading-anchor" href="#15.1-Query-Hooks">15.1 Query Hooks</a><a id="15.1-Query-Hooks-1"></a><a class="docs-heading-anchor-permalink" href="#15.1-Query-Hooks" title="Permalink"></a></h3><p>The Core layer supports query-level hooks that receive structured events, including:</p><ul><li>the generated SQL string</li><li>parameter metadata (keys and order)</li><li>execution timing</li><li>row counts (when available)</li><li>execution errors</li></ul><p>These hooks enable integration with:</p><ul><li>logging systems</li><li>tracing frameworks</li><li>metrics collection</li><li>ad-hoc debugging tools</li></ul><p>Observability is treated as a first-class concern, not an afterthought.</p><hr/><h3 id="15.2-Explain-and-Debugging-Support"><a class="docs-heading-anchor" href="#15.2-Explain-and-Debugging-Support">15.2 Explain and Debugging Support</a><a id="15.2-Explain-and-Debugging-Support-1"></a><a class="docs-heading-anchor-permalink" href="#15.2-Explain-and-Debugging-Support" title="Permalink"></a></h3><p>SQLSketch.jl provides explicit support for query inspection via:</p><ul><li><code>sql(query)</code> for raw SQL inspection</li><li><code>compile(query)</code> for SQL and parameter ordering</li><li><code>explain(query)</code> for database execution plans (when supported)</li></ul><p>This allows performance issues to be investigated without instrumenting internal code paths.</p><hr/><h2 id="17.-Testing-Strategy"><a class="docs-heading-anchor" href="#17.-Testing-Strategy">17. Testing Strategy</a><a id="17.-Testing-Strategy-1"></a><a class="docs-heading-anchor-permalink" href="#17.-Testing-Strategy" title="Permalink"></a></h2><p>Testing is structured to reflect the layered architecture and multi-database goals of SQLSketch.jl.</p><hr/><h3 id="17.1-Unit-Tests"><a class="docs-heading-anchor" href="#17.1-Unit-Tests">17.1 Unit Tests</a><a id="17.1-Unit-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#17.1-Unit-Tests" title="Permalink"></a></h3><p>Unit tests focus on <strong>pure logic</strong> and do not require a database.</p><p>Typical unit test targets include:</p><ul><li>Expression and Query AST construction</li><li>SQL compilation for each Dialect</li><li>Capability reporting</li><li>CodecRegistry encode/decode behavior</li></ul><p>These tests are fast and form the bulk of the test suite.</p><hr/><h3 id="17.2-Integration-Tests-(SQLite)"><a class="docs-heading-anchor" href="#17.2-Integration-Tests-(SQLite)">17.2 Integration Tests (SQLite)</a><a id="17.2-Integration-Tests-(SQLite)-1"></a><a class="docs-heading-anchor-permalink" href="#17.2-Integration-Tests-(SQLite)" title="Permalink"></a></h3><p>Integration tests use <strong>SQLite in-memory databases</strong>.</p><p>They validate:</p><ul><li>end-to-end query execution</li><li>parameter binding</li><li>row decoding and mapping</li><li>transaction commit and rollback</li><li>migration application</li></ul><p>SQLite enables fast, deterministic tests suitable for CI environments.</p><hr/><h3 id="17.3-Compatibility-Tests-(PostgreSQL-/-MySQL)"><a class="docs-heading-anchor" href="#17.3-Compatibility-Tests-(PostgreSQL-/-MySQL)">17.3 Compatibility Tests (PostgreSQL / MySQL)</a><a id="17.3-Compatibility-Tests-(PostgreSQL-/-MySQL)-1"></a><a class="docs-heading-anchor-permalink" href="#17.3-Compatibility-Tests-(PostgreSQL-/-MySQL)" title="Permalink"></a></h3><p>A small number of compatibility tests are run against PostgreSQL and MySQL.</p><p>These tests focus on:</p><ul><li>dialect-specific SQL generation</li><li>feature-gated capabilities (e.g. RETURNING, UPSERT)</li><li>type behavior differences</li><li>transaction semantics</li></ul><p>Compatibility tests are intentionally limited in scope to avoid slowing down development.</p><hr/><h2 id="18.-Project-Positioning"><a class="docs-heading-anchor" href="#18.-Project-Positioning">18. Project Positioning</a><a id="18.-Project-Positioning-1"></a><a class="docs-heading-anchor-permalink" href="#18.-Project-Positioning" title="Permalink"></a></h2><p>SQLSketch.jl is intentionally positioned as:</p><ul><li>exploratory</li><li>educational</li><li>experimental</li><li>replaceable</li></ul><p>It is not intended to be a drop-in replacement for mature ORMs or database abstraction layers.</p><hr/><h3 id="17.1-Design-Exploration"><a class="docs-heading-anchor" href="#17.1-Design-Exploration">17.1 Design Exploration</a><a id="17.1-Design-Exploration-1"></a><a class="docs-heading-anchor-permalink" href="#17.1-Design-Exploration" title="Permalink"></a></h3><p>The primary goal of SQLSketch.jl is to explore:</p><ul><li>how far a small, principled SQL core can go</li><li>which abstractions are useful or harmful</li><li>how to balance type safety with SQL transparency</li><li>how Julia’s strengths apply to query construction</li></ul><hr/><h3 id="17.2-Evolution-and-Exit-Strategy"><a class="docs-heading-anchor" href="#17.2-Evolution-and-Exit-Strategy">17.2 Evolution and Exit Strategy</a><a id="17.2-Evolution-and-Exit-Strategy-1"></a><a class="docs-heading-anchor-permalink" href="#17.2-Evolution-and-Exit-Strategy" title="Permalink"></a></h3><p>If ideas explored in SQLSketch.jl prove valuable, they may be:</p><ul><li>extracted into separate libraries</li><li>renamed and formalized</li><li>upstreamed into more production-oriented projects</li></ul><p>Conversely, if certain ideas do not work well, they can be discarded without regret.</p><p>This flexibility is a deliberate design choice.</p><hr/><h2 id="19.-Summary"><a class="docs-heading-anchor" href="#19.-Summary">19. Summary</a><a id="19.-Summary-1"></a><a class="docs-heading-anchor-permalink" href="#19.-Summary" title="Permalink"></a></h2><p>SQLSketch.jl explores how to build a <strong>typed, composable SQL core</strong> without becoming a full ORM.</p><p>It prioritizes:</p><ul><li>clarity over completeness</li><li>explicitness over convenience</li><li>design exploration over polish</li></ul><p>By keeping the Core small and principled, SQLSketch.jl provides a safe environment for experimentation while remaining grounded in real-world database usage.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/">« API Reference</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 21 December 2025 18:06">Sunday 21 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
