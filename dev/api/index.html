<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · SQLSketch.jl</title><meta name="title" content="API Reference · SQLSketch.jl"/><meta property="og:title" content="API Reference · SQLSketch.jl"/><meta property="twitter:title" content="API Reference · SQLSketch.jl"/><meta name="description" content="Documentation for SQLSketch.jl."/><meta property="og:description" content="Documentation for SQLSketch.jl."/><meta property="twitter:description" content="Documentation for SQLSketch.jl."/><meta property="og:url" content="https://daikichiba9511.github.io/SQLSketch.jl/api/"/><meta property="twitter:url" content="https://daikichiba9511.github.io/SQLSketch.jl/api/"/><link rel="canonical" href="https://daikichiba9511.github.io/SQLSketch.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SQLSketch.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Query-Building"><span>Query Building</span></a></li><li><a class="tocitem" href="#DML-Operations"><span>DML Operations</span></a></li><li><a class="tocitem" href="#DDL-Operations"><span>DDL Operations</span></a></li><li><a class="tocitem" href="#Expressions"><span>Expressions</span></a></li><li><a class="tocitem" href="#Query-Execution"><span>Query Execution</span></a></li><li><a class="tocitem" href="#SQL-Generation"><span>SQL Generation</span></a></li><li><a class="tocitem" href="#Dialects"><span>Dialects</span></a></li><li><a class="tocitem" href="#Drivers"><span>Drivers</span></a></li><li><a class="tocitem" href="#Migration-System"><span>Migration System</span></a></li></ul></li><li><a class="tocitem" href="../design/">Design</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/main/docs/src/api.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Query-Building"><a class="docs-heading-anchor" href="#Query-Building">Query Building</a><a id="Query-Building-1"></a><a class="docs-heading-anchor-permalink" href="#Query-Building" title="Permalink"></a></h2><h3 id="Starting-Queries"><a class="docs-heading-anchor" href="#Starting-Queries">Starting Queries</a><a id="Starting-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Starting-Queries" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.from"><a class="docstring-binding" href="#SQLSketch.Core.from"><code>SQLSketch.Core.from</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">from(table::Symbol) -&gt; From{NamedTuple}</code></pre><p>Creates a FROM clause as the starting point of a query.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:users)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/query.jl#L292-L302">source</a></section></details></article><h3 id="Filtering-and-Conditions"><a class="docs-heading-anchor" href="#Filtering-and-Conditions">Filtering and Conditions</a><a id="Filtering-and-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering-and-Conditions" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.where"><a class="docstring-binding" href="#SQLSketch.Core.where"><code>SQLSketch.Core.where</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">where(q, condition)</code></pre><p>Adds a WHERE clause to filter rows.</p><p>This is a <strong>shape-preserving</strong> operation.</p><p>Can be used in two ways:</p><ul><li>Explicit: <code>where(query, condition)</code></li><li>Pipeline: <code>query |&gt; where(condition)</code></li></ul><p>The curried form <code>where(condition)</code> returns a function suitable for pipeline composition.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Pipeline style
q = from(:users) |&gt; where(col(:users, :active) == literal(true))

# Explicit style
q = where(from(:users), col(:users, :active) == literal(true))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/query.jl#L307-L330">source</a></section><section><div><pre><code class="language-julia hljs">where(source::UpdateSet{T}, condition::SQLExpr) -&gt; UpdateWhere{T}</code></pre><p>Add WHERE clause to UPDATE (explicit version).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/query.jl#L962-L966">source</a></section><section><div><pre><code class="language-julia hljs">where(source::DeleteFrom{T}, condition::SQLExpr) -&gt; DeleteWhere{T}</code></pre><p>Add WHERE clause to DELETE (explicit version).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/query.jl#L985-L989">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.having"><a class="docstring-binding" href="#SQLSketch.Core.having"><code>SQLSketch.Core.having</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">having(q::Query{T}, condition::SQLExpr)::Having{T}</code></pre><p>Adds a HAVING clause (used with GROUP BY).</p><p>This is a <strong>shape-preserving</strong> operation.</p><p>Can be used in two ways:</p><ul><li>Explicit: <code>having(query, condition)</code></li><li>Pipeline: <code>query |&gt; having(condition)</code></li></ul><p>The curried form <code>having(condition)</code> returns a function suitable for pipeline composition.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:orders) |&gt;
    group_by(col(:orders, :user_id)) |&gt;
    having(func(:COUNT, [col(:orders, :id)]) &gt; literal(5))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/query.jl#L502-L523">source</a></section></details></article><h3 id="Selecting-Columns"><a class="docs-heading-anchor" href="#Selecting-Columns">Selecting Columns</a><a id="Selecting-Columns-1"></a><a class="docs-heading-anchor-permalink" href="#Selecting-Columns" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.select"><a class="docstring-binding" href="#SQLSketch.Core.select"><code>SQLSketch.Core.select</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">select(q::Query, OutT::Type, fields::SQLExpr...) -&gt; Select{OutT}</code></pre><p>Adds a SELECT clause to project specific columns.</p><p>This is the <strong>only shape-changing</strong> operation – it changes the output type to <code>OutT</code>.</p><p>Can be used in two ways:</p><ul><li>Explicit: <code>select(query, OutT, fields...)</code></li><li>Pipeline: <code>query |&gt; select(OutT, fields...)</code></li></ul><p>The curried form <code>select(OutT, fields...)</code> returns a function suitable for pipeline composition.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Pipeline style
q = from(:users) |&gt; select(NamedTuple, col(:users, :id), col(:users, :email))

# Explicit style
q = select(from(:users), NamedTuple, col(:users, :id), col(:users, :email))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/query.jl#L338-L361">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.distinct"><a class="docstring-binding" href="#SQLSketch.Core.distinct"><code>SQLSketch.Core.distinct</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">distinct(q::Query{T}) -&gt; Distinct{T}</code></pre><p>Adds a DISTINCT clause.</p><p>This is a <strong>shape-preserving</strong> operation.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:users) |&gt; select(NamedTuple, col(:users, :email)) |&gt; distinct</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/query.jl#L458-L470">source</a></section></details></article><h3 id="Ordering-and-Limiting"><a class="docs-heading-anchor" href="#Ordering-and-Limiting">Ordering and Limiting</a><a id="Ordering-and-Limiting-1"></a><a class="docs-heading-anchor-permalink" href="#Ordering-and-Limiting" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.order_by"><a class="docstring-binding" href="#SQLSketch.Core.order_by"><code>SQLSketch.Core.order_by</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">order_by(q::Query{T}, field::SQLExpr; desc::Bool=false)::OrderBy{T}</code></pre><p>Adds an ORDER BY clause.</p><p>This is a <strong>shape-preserving</strong> operation.</p><p>Can be used in two ways:</p><ul><li>Explicit: <code>order_by(query, field, desc=false)</code></li><li>Pipeline: <code>query |&gt; order_by(field, desc=false)</code></li></ul><p>The curried form <code>order_by(field; desc=false)</code> returns a function suitable for pipeline composition.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Pipeline style
q = from(:users) |&gt; order_by(col(:users, :created_at); desc = true)

# Explicit style
q = order_by(from(:users), col(:users, :created_at); desc = true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/query.jl#L368-L391">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.limit"><a class="docstring-binding" href="#SQLSketch.Core.limit"><code>SQLSketch.Core.limit</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">limit(q::Query{T}, n::Int)::Limit{T}</code></pre><p>Adds a LIMIT clause.</p><p>This is a <strong>shape-preserving</strong> operation.</p><p>Can be used in two ways:</p><ul><li>Explicit: <code>limit(query, n)</code></li><li>Pipeline: <code>query |&gt; limit(n)</code></li></ul><p>The curried form <code>limit(n)</code> returns a function suitable for pipeline composition.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:users) |&gt; limit(10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/query.jl#L404-L423">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.offset"><a class="docstring-binding" href="#SQLSketch.Core.offset"><code>SQLSketch.Core.offset</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">offset(q::Query{T}, n::Int)::Offset{T}</code></pre><p>Adds an OFFSET clause.</p><p>This is a <strong>shape-preserving</strong> operation.</p><p>Can be used in two ways:</p><ul><li>Explicit: <code>offset(query, n)</code></li><li>Pipeline: <code>query |&gt; offset(n)</code></li></ul><p>The curried form <code>offset(n)</code> returns a function suitable for pipeline composition.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:users) |&gt; offset(20)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/query.jl#L431-L450">source</a></section></details></article><h3 id="Grouping"><a class="docs-heading-anchor" href="#Grouping">Grouping</a><a id="Grouping-1"></a><a class="docs-heading-anchor-permalink" href="#Grouping" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.group_by"><a class="docstring-binding" href="#SQLSketch.Core.group_by"><code>SQLSketch.Core.group_by</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">group_by(q::Query{T}, fields::SQLExpr...)::GroupBy{T}</code></pre><p>Adds a GROUP BY clause.</p><p>This is a <strong>shape-preserving</strong> operation.</p><p>Can be used in two ways:</p><ul><li>Explicit: <code>group_by(query, fields...)</code></li><li>Pipeline: <code>query |&gt; group_by(fields...)</code></li></ul><p>The curried form <code>group_by(fields...)</code> returns a function suitable for pipeline composition.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:orders) |&gt; group_by(col(:orders, :user_id))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/query.jl#L475-L494">source</a></section></details></article><h2 id="DML-Operations"><a class="docs-heading-anchor" href="#DML-Operations">DML Operations</a><a id="DML-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#DML-Operations" title="Permalink"></a></h2><h3 id="INSERT"><a class="docs-heading-anchor" href="#INSERT">INSERT</a><a id="INSERT-1"></a><a class="docs-heading-anchor-permalink" href="#INSERT" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.insert_into"><a class="docstring-binding" href="#SQLSketch.Core.insert_into"><code>SQLSketch.Core.insert_into</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">insert_into(table::Symbol, columns::Vector{Symbol}) -&gt; InsertInto{NamedTuple}</code></pre><p>Create an INSERT INTO clause.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = insert_into(:users, [:name, :email]) |&gt;
    values([[literal(&quot;Alice&quot;), literal(&quot;alice@example.com&quot;)]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/query.jl#L852-L863">source</a></section></details></article><h3 id="UPDATE"><a class="docs-heading-anchor" href="#UPDATE">UPDATE</a><a id="UPDATE-1"></a><a class="docs-heading-anchor-permalink" href="#UPDATE" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.update"><a class="docstring-binding" href="#SQLSketch.Core.update"><code>SQLSketch.Core.update</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">update(table::Symbol) -&gt; Update{NamedTuple}</code></pre><p>Create an UPDATE statement.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = update(:users) |&gt;
    set(:name =&gt; param(String, :name)) |&gt;
    where(col(:users, :id) == param(Int, :id))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/query.jl#L919-L931">source</a></section></details></article><h3 id="DELETE"><a class="docs-heading-anchor" href="#DELETE">DELETE</a><a id="DELETE-1"></a><a class="docs-heading-anchor-permalink" href="#DELETE" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.delete_from"><a class="docstring-binding" href="#SQLSketch.Core.delete_from"><code>SQLSketch.Core.delete_from</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">delete_from(table::Symbol) -&gt; DeleteFrom{NamedTuple}</code></pre><p>Create a DELETE FROM statement.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = delete_from(:users) |&gt;
    where(col(:users, :id) == param(Int, :id))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/query.jl#L971-L982">source</a></section></details></article><h3 id="RETURNING"><a class="docs-heading-anchor" href="#RETURNING">RETURNING</a><a id="RETURNING-1"></a><a class="docs-heading-anchor-permalink" href="#RETURNING" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.returning"><a class="docstring-binding" href="#SQLSketch.Core.returning"><code>SQLSketch.Core.returning</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">returning(q::Query, OutT::Type, fields...)::Returning{OutT}</code></pre><p>Add a RETURNING clause to a DML operation.</p><p>This is a shape-changing operation that transforms a DML query into a query that returns typed results from the affected rows.</p><p><strong>Arguments</strong></p><ul><li><code>q</code>: DML query (InsertValues, UpdateSet, UpdateWhere, DeleteFrom, or DeleteWhere)</li><li><code>OutT</code>: Output type (typically NamedTuple or a struct type)</li><li><code>fields...</code>: Expressions for fields to return</li></ul><p><strong>Returns</strong></p><p>A <code>Returning{OutT}</code> query node</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Basic RETURNING with placeholder syntax
q = insert_into(:users, [:email]) |&gt;
    values([[literal(&quot;test@example.com&quot;)]]) |&gt;
    returning(NamedTuple, p_.id, p_.email)

# RETURNING with explicit column references
q = update(:users) |&gt;
    set(:status =&gt; literal(&quot;active&quot;)) |&gt;
    where(col(:users, :id) == param(Int, :id)) |&gt;
    returning(NamedTuple, col(:users, :id), col(:users, :status))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/query.jl#L1084-L1116">source</a></section><section><div><pre><code class="language-julia hljs">returning(OutT::Type, fields...)</code></pre><p>Curried version of <code>returning</code> for pipeline composition.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = insert_into(:users, [:email]) |&gt;
    values([[literal(&quot;test@example.com&quot;)]]) |&gt;
    returning(NamedTuple, p_.id, p_.email)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/query.jl#L1121-L1133">source</a></section></details></article><h2 id="DDL-Operations"><a class="docs-heading-anchor" href="#DDL-Operations">DDL Operations</a><a id="DDL-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#DDL-Operations" title="Permalink"></a></h2><h3 id="Table-Operations"><a class="docs-heading-anchor" href="#Table-Operations">Table Operations</a><a id="Table-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Table-Operations" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.create_table"><a class="docstring-binding" href="#SQLSketch.Core.create_table"><code>SQLSketch.Core.create_table</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_table(table::Symbol; if_not_exists::Bool=false, temporary::Bool=false) -&gt; CreateTable</code></pre><p>Create a CREATE TABLE statement.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">create_table(:users)
create_table(:users; if_not_exists = true)
create_table(:temp_data; temporary = true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/ddl.jl#L589-L601">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.alter_table"><a class="docstring-binding" href="#SQLSketch.Core.alter_table"><code>SQLSketch.Core.alter_table</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">alter_table(table::Symbol) -&gt; AlterTable</code></pre><p>Create an ALTER TABLE statement.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">alter_table(:users) |&gt;
add_alter_column(:age, :integer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/ddl.jl#L906-L917">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.drop_table"><a class="docstring-binding" href="#SQLSketch.Core.drop_table"><code>SQLSketch.Core.drop_table</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">drop_table(table::Symbol; if_exists::Bool=false, cascade::Bool=false) -&gt; DropTable</code></pre><p>Create a DROP TABLE statement.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">drop_table(:users)
drop_table(:users; if_exists = true)
drop_table(:users; cascade = true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/ddl.jl#L1096-L1108">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.add_column"><a class="docstring-binding" href="#SQLSketch.Core.add_column"><code>SQLSketch.Core.add_column</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add_column(ct::CreateTable, name::Symbol, type::ColumnType;
           primary_key::Bool=false, nullable::Bool=true, unique::Bool=false,
           default::Union{SQLExpr, Nothing}=nothing,
           references::Union{Tuple{Symbol, Symbol}, Nothing}=nothing,
           check::Union{SQLExpr, Nothing}=nothing,
           auto_increment::Bool=false,
           generated::Union{SQLExpr, Nothing}=nothing,
           stored::Bool=true,
           collation::Union{Symbol, Nothing}=nothing,
           on_update::Union{SQLExpr, Nothing}=nothing,
           comment::Union{String, Nothing}=nothing,
           identity::Bool=false,
           identity_always::Bool=false,
           identity_start::Union{Int, Nothing}=nothing,
           identity_increment::Union{Int, Nothing}=nothing) -&gt; CreateTable</code></pre><p>Add a column to a CREATE TABLE statement.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>primary_key::Bool</code> – Mark as PRIMARY KEY</li><li><code>nullable::Bool</code> – Allow NULL values (default true)</li><li><code>unique::Bool</code> – Add UNIQUE constraint</li><li><code>default::Union{SQLExpr, Nothing}</code> – Default value expression</li><li><code>references::Union{Tuple{Symbol, Symbol}, Nothing}</code> – Foreign key reference (table, column)</li><li><code>check::Union{SQLExpr, Nothing}</code> – Column-level CHECK constraint</li><li><code>auto_increment::Bool</code> – AUTO_INCREMENT / SERIAL (dialect-specific)</li><li><code>generated::Union{SQLExpr, Nothing}</code> – GENERATED column expression</li><li><code>stored::Bool</code> – STORED (true) or VIRTUAL (false) for GENERATED columns</li><li><code>collation::Union{Symbol, Nothing}</code> – COLLATE clause for string columns</li><li><code>on_update::Union{SQLExpr, Nothing}</code> – ON UPDATE clause (MySQL)</li><li><code>comment::Union{String, Nothing}</code> – Column comment</li><li><code>identity::Bool</code> – IDENTITY column (PostgreSQL)</li><li><code>identity_always::Bool</code> – ALWAYS (true) or BY DEFAULT (false) for IDENTITY</li><li><code>identity_start::Union{Int, Nothing}</code> – Starting value for IDENTITY</li><li><code>identity_increment::Union{Int, Nothing}</code> – Increment value for IDENTITY</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">create_table(:users) |&gt;
add_column(:id, :integer; primary_key = true, auto_increment = true) |&gt;
add_column(:email, :text; nullable = false, unique = true, collation = :nocase) |&gt;
add_column(:age, :integer; check = col(:users, :age) &gt;= literal(0)) |&gt;
add_column(:created_at, :timestamp; default = literal(:current_timestamp))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/ddl.jl#L608-L655">source</a></section><section><div><pre><code class="language-julia hljs">add_column(name::Symbol, type::ColumnType; kwargs...) -&gt; Function</code></pre><p>Curried version of <code>add_column</code> for pipeline composition.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">create_table(:users) |&gt;
add_column(:id, :integer; primary_key = true, auto_increment = true) |&gt;
add_column(:email, :text; nullable = false, collation = :nocase)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/ddl.jl#L734-L746">source</a></section></details></article><h3 id="Index-Operations"><a class="docs-heading-anchor" href="#Index-Operations">Index Operations</a><a id="Index-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Index-Operations" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.create_index"><a class="docstring-binding" href="#SQLSketch.Core.create_index"><code>SQLSketch.Core.create_index</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_index(name::Symbol, table::Symbol, columns::Vector{Symbol};
             unique::Bool=false, if_not_exists::Bool=false,
             where::Union{SQLExpr, Nothing}=nothing) -&gt; CreateIndex</code></pre><p>Create a CREATE INDEX statement.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">create_index(:idx_users_email, :users, [:email])
create_index(:idx_users_email, :users, [:email]; unique = true)
create_index(:idx_active_users, :users, [:id];
             where = col(:users, :active) == literal(true))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/ddl.jl#L1118-L1133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.drop_index"><a class="docstring-binding" href="#SQLSketch.Core.drop_index"><code>SQLSketch.Core.drop_index</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">drop_index(name::Symbol; if_exists::Bool=false) -&gt; DropIndex</code></pre><p>Create a DROP INDEX statement.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">drop_index(:idx_users_email)
drop_index(:idx_users_email; if_exists = true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/ddl.jl#L1154-L1165">source</a></section></details></article><h2 id="Expressions"><a class="docs-heading-anchor" href="#Expressions">Expressions</a><a id="Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Expressions" title="Permalink"></a></h2><h3 id="Column-References"><a class="docs-heading-anchor" href="#Column-References">Column References</a><a id="Column-References-1"></a><a class="docs-heading-anchor-permalink" href="#Column-References" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.col"><a class="docstring-binding" href="#SQLSketch.Core.col"><code>SQLSketch.Core.col</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">col(table::Symbol, column::Symbol) -&gt; ColRef</code></pre><p>Convenience constructor for column references.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/expr.jl#L68-L72">source</a></section></details></article><h3 id="Literals-and-Parameters"><a class="docs-heading-anchor" href="#Literals-and-Parameters">Literals and Parameters</a><a id="Literals-and-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Literals-and-Parameters" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.literal"><a class="docstring-binding" href="#SQLSketch.Core.literal"><code>SQLSketch.Core.literal</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">literal(value::Any) -&gt; Literal</code></pre><p>Convenience constructor for literal values. Accepts any Julia value to be embedded as a literal in SQL.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/expr.jl#L95-L100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.param"><a class="docstring-binding" href="#SQLSketch.Core.param"><code>SQLSketch.Core.param</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">param(T::Type, name::Symbol) -&gt; Param</code></pre><p>Convenience constructor for bound parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/expr.jl#L129-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Extras.p_"><a class="docstring-binding" href="#SQLSketch.Extras.p_"><code>SQLSketch.Extras.p_</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const p_ = Placeholder()</code></pre><p>Global placeholder constant for convenient field access.</p><p>Note: Uses <code>p_</code> instead of <code>_</code> because Julia reserves underscore-only identifiers for write-only variables.</p><p><strong>Usage</strong></p><pre><code class="language-julia hljs">from(:users) |&gt;
where(p_.age &gt; literal(18)) |&gt;
select(NamedTuple, p_.id, p_.email)</code></pre><p>Internally, <code>p_.column</code> creates a <code>PlaceholderField(:column)</code> which is resolved to <code>ColRef(table, :column)</code> during query compilation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Extras/placeholder.jl#L94-L112">source</a></section></details></article><h3 id="Comparisons"><a class="docs-heading-anchor" href="#Comparisons">Comparisons</a><a id="Comparisons-1"></a><a class="docs-heading-anchor-permalink" href="#Comparisons" title="Permalink"></a></h3><p>Binary operators are overloaded for <code>SQLExpr</code>:</p><ul><li><code>==</code>, <code>!=</code> - Equality/inequality</li><li><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> - Comparison</li><li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> - Arithmetic</li><li><code>&amp;</code> (and), <code>|</code> (or) - Logical operators</li></ul><h3 id="Type-Conversion"><a class="docs-heading-anchor" href="#Type-Conversion">Type Conversion</a><a id="Type-Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Conversion" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.cast"><a class="docstring-binding" href="#SQLSketch.Core.cast"><code>SQLSketch.Core.cast</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cast(expr::SQLExpr, target_type::Symbol) -&gt; Cast</code></pre><p>Convenience constructor for type casting.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">cast(col(:users, :age), :TEXT)
# → CAST(users.age AS TEXT)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/expr.jl#L623-L634">source</a></section></details></article><h3 id="Subqueries"><a class="docs-heading-anchor" href="#Subqueries">Subqueries</a><a id="Subqueries-1"></a><a class="docs-heading-anchor-permalink" href="#Subqueries" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.subquery"><a class="docstring-binding" href="#SQLSketch.Core.subquery"><code>SQLSketch.Core.subquery</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">subquery(query) -&gt; Subquery</code></pre><p>Convenience constructor for subquery expressions.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">sq = subquery(from(:orders) |&gt; select(NamedTuple, col(:orders, :user_id)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/expr.jl#L681-L691">source</a></section></details></article><h2 id="Query-Execution"><a class="docs-heading-anchor" href="#Query-Execution">Query Execution</a><a id="Query-Execution-1"></a><a class="docs-heading-anchor-permalink" href="#Query-Execution" title="Permalink"></a></h2><p>SQLSketch separates <strong>data retrieval</strong> from <strong>side-effecting operations</strong>.</p><p><strong>Key distinction:</strong></p><ul><li>Use <strong><code>fetch_*</code></strong> when you want to <strong>retrieve data</strong> (SELECT, INSERT/UPDATE/DELETE with RETURNING)</li><li>Use <strong><code>execute</code></strong> when you want to <strong>produce side effects</strong> without retrieving data (INSERT, UPDATE, DELETE, CREATE TABLE, etc.)</li></ul><p><strong>Quick reference:</strong></p><table><tr><th style="text-align: right">Function</th><th style="text-align: right">Returns</th><th style="text-align: right">Use Case</th></tr><tr><td style="text-align: right"><code>fetch_all(conn, query, T)</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Get all rows</td></tr><tr><td style="text-align: right"><code>fetch_one(conn, query, T)</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Get exactly one row (error if 0 or &gt;1)</td></tr><tr><td style="text-align: right"><code>fetch_maybe(conn, query, T)</code></td><td style="text-align: right"><code>Union{T, Nothing}</code></td><td style="text-align: right">Get optional row</td></tr><tr><td style="text-align: right"><code>execute(conn, query)</code></td><td style="text-align: right"><code>Int64</code></td><td style="text-align: right">Perform side effects (returns affected row count)</td></tr></table><p>See <a href="../design/#13-query-execution-model">Design - Query Execution Model</a> for detailed rationale.</p><h3 id="Fetching-Results"><a class="docs-heading-anchor" href="#Fetching-Results">Fetching Results</a><a id="Fetching-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Fetching-Results" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.fetch_all"><a class="docstring-binding" href="#SQLSketch.Core.fetch_all"><code>SQLSketch.Core.fetch_all</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fetch_all(conn::Connection, dialect::Dialect, registry::CodecRegistry,
          query::Query{T}, params::NamedTuple = NamedTuple()) -&gt; Vector{T}</code></pre><p>Execute a query and fetch all rows.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Database connection</li><li><code>dialect</code>: SQL dialect for compilation</li><li><code>registry</code>: Codec registry for type conversion</li><li><code>query</code>: Query AST to execute</li><li><code>params</code>: Named parameters for the query (default: empty NamedTuple)</li></ul><p><strong>Returns</strong></p><p>Vector of results of type T (where T is the query&#39;s output type)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:users) |&gt;
    where(col(:users, :age) &gt; param(Int, :min_age)) |&gt;
    select(NamedTuple, col(:users, :id), col(:users, :name))

results = fetch_all(db, dialect, registry, q, (min_age = 25,))
# → Vector{NamedTuple}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/execute.jl#L145-L173">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.fetch_one"><a class="docstring-binding" href="#SQLSketch.Core.fetch_one"><code>SQLSketch.Core.fetch_one</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fetch_one(conn::Connection, dialect::Dialect, registry::CodecRegistry,
          query::Query{T}, params::NamedTuple = NamedTuple()) -&gt; T</code></pre><p>Execute a query and fetch exactly one row.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Database connection</li><li><code>dialect</code>: SQL dialect for compilation</li><li><code>registry</code>: Codec registry for type conversion</li><li><code>query</code>: Query AST to execute</li><li><code>params</code>: Named parameters for the query (default: empty NamedTuple)</li></ul><p><strong>Returns</strong></p><p>Single result of type T</p><p><strong>Errors</strong></p><ul><li>Throws an error if the query returns zero rows</li><li>Throws an error if the query returns more than one row</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:users) |&gt;
    where(col(:users, :id) == param(Int, :id)) |&gt;
    select(NamedTuple, col(:users, :id), col(:users, :email))

user = fetch_one(db, dialect, registry, q, (id = 1,))
# → NamedTuple (exactly one row)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/execute.jl#L223-L256">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.fetch_maybe"><a class="docstring-binding" href="#SQLSketch.Core.fetch_maybe"><code>SQLSketch.Core.fetch_maybe</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fetch_maybe(conn::Connection, dialect::Dialect, registry::CodecRegistry,
            query::Query{T}, params::NamedTuple = NamedTuple()) -&gt; Union{T, Nothing}</code></pre><p>Execute a query and fetch zero or one row.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Database connection</li><li><code>dialect</code>: SQL dialect for compilation</li><li><code>registry</code>: Codec registry for type conversion</li><li><code>query</code>: Query AST to execute</li><li><code>params</code>: Named parameters for the query (default: empty NamedTuple)</li></ul><p><strong>Returns</strong></p><ul><li>Single result of type T if exactly one row is returned</li><li><code>Nothing</code> if zero rows are returned</li></ul><p><strong>Errors</strong></p><p>Throws an error if the query returns more than one row</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:users) |&gt;
    where(col(:users, :email) == param(String, :email)) |&gt;
    select(NamedTuple, col(:users, :id), col(:users, :email))

user = fetch_maybe(db, dialect, registry, q, (email = &quot;test@example.com&quot;,))
# → NamedTuple or Nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/execute.jl#L290-L323">source</a></section></details></article><h3 id="Executing-Statements"><a class="docs-heading-anchor" href="#Executing-Statements">Executing Statements</a><a id="Executing-Statements-1"></a><a class="docs-heading-anchor-permalink" href="#Executing-Statements" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.execute"><a class="docstring-binding" href="#SQLSketch.Core.execute"><code>SQLSketch.Core.execute</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">execute(conn::Connection, dialect::Dialect, query::Query,
        params::NamedTuple = NamedTuple()) -&gt; ExecResult</code></pre><p>Unified API for executing DML statements (INSERT, UPDATE, DELETE) with side effects.</p><p>This is the recommended API for all DML execution. Dispatches internally to <code>execute_dml</code>.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Database connection</li><li><code>dialect</code>: SQL dialect for compilation</li><li><code>query</code>: DML query AST</li><li><code>params</code>: Named parameters for the query (default: empty NamedTuple)</li></ul><p><strong>Returns</strong></p><p>ExecResult containing:</p><ul><li><code>command_type::Symbol</code>: Type of command executed (:insert, :update, :delete)</li><li><code>rowcount::Union{Int, Nothing}</code>: Number of rows affected (currently Nothing)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># INSERT
q = insert_into(:users, [:name, :email]) |&gt;
    values([[literal(&quot;Alice&quot;), literal(&quot;alice@example.com&quot;)]])
result = execute(conn, dialect, q)
# -&gt; ExecResult(:insert, nothing)

# UPDATE
q = update(:users) |&gt;
    set(:status =&gt; literal(&quot;inactive&quot;)) |&gt;
    where(col(:users, :age) &gt; literal(100))
result = execute(conn, dialect, q)
# -&gt; ExecResult(:update, nothing)

# DELETE
q = delete_from(:users) |&gt;
    where(col(:users, :status) == literal(&quot;deleted&quot;))
result = execute(conn, dialect, q)
# -&gt; ExecResult(:delete, nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/execute.jl#L513-L557">source</a></section><section><div><pre><code class="language-julia hljs">execute(conn::Connection, dialect::Dialect, ddl::DDLStatement) -&gt; ExecResult</code></pre><p>Unified API for executing DDL statements (CREATE TABLE, DROP TABLE, etc.) with side effects.</p><p>This is the recommended API for all DDL execution. Dispatches internally to <code>execute_ddl</code>.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Database connection</li><li><code>dialect</code>: SQL dialect for compilation</li><li><code>ddl</code>: DDL statement AST</li></ul><p><strong>Returns</strong></p><p>ExecResult containing:</p><ul><li><code>command_type::Symbol</code>: Type of command executed (:create<em>table, :drop</em>table, etc.)</li><li><code>rowcount::Union{Int, Nothing}</code>: Always nothing for DDL</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># CREATE TABLE
ddl = create_table(:users) |&gt;
      add_column(:id, :integer; primary_key = true) |&gt;
      add_column(:name, :text; nullable = false)
result = execute(conn, dialect, ddl)
# -&gt; ExecResult(:create_table, nothing)

# DROP TABLE
ddl = drop_table(:users; if_exists = true)
result = execute(conn, dialect, ddl)
# -&gt; ExecResult(:drop_table, nothing)

# CREATE INDEX
ddl = create_index(:idx_users_email) |&gt; on(:users, :email)
result = execute(conn, dialect, ddl)
# -&gt; ExecResult(:create_index, nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/ddl.jl#L1254-L1294">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.ExecResult"><a class="docstring-binding" href="#SQLSketch.Core.ExecResult"><code>SQLSketch.Core.ExecResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ExecResult</code></pre><p>Result of executing a statement with side effects (DML/DDL).</p><p><strong>Fields</strong></p><ul><li><code>command_type::Symbol</code>: Type of command executed (:insert, :update, :delete, :create<em>table, :drop</em>table, :alter<em>table, :create</em>index, :drop_index, :unknown)</li><li><code>rowcount::Union{Int, Nothing}</code>: Number of rows affected (Nothing if unknown or not applicable)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">result = execute(conn, dialect, insert_query, params)
println(result.command_type)  # :insert
println(result.rowcount)      # Nothing (currently not implemented)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/execute.jl#L56-L73">source</a></section></details></article><h3 id="Transactions"><a class="docs-heading-anchor" href="#Transactions">Transactions</a><a id="Transactions-1"></a><a class="docs-heading-anchor-permalink" href="#Transactions" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.transaction"><a class="docstring-binding" href="#SQLSketch.Core.transaction"><code>SQLSketch.Core.transaction</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">transaction(f::Function, conn::SQLiteConnection) -&gt; result</code></pre><p>Execute a function within a SQLite transaction.</p><p>Uses BEGIN TRANSACTION / COMMIT / ROLLBACK commands.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Function to execute. Receives SQLiteTransaction handle as argument.</li><li><code>conn</code>: SQLite database connection</li></ul><p><strong>Returns</strong></p><p>The return value of the function <code>f</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">result = transaction(db) do tx
    execute(tx, &quot;INSERT INTO users (email) VALUES (?)&quot;, [&quot;alice@example.com&quot;])
    execute(tx, &quot;INSERT INTO orders (user_id, total) VALUES (?, ?)&quot;, [1, 100.0])
    return &quot;success&quot;
end</code></pre><p><strong>Implementation Details</strong></p><ul><li>BEGIN TRANSACTION starts the transaction</li><li>COMMIT is executed if the function completes successfully</li><li>ROLLBACK is executed if an exception occurs</li><li>The transaction handle can be used with execute() and all query execution APIs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Drivers/sqlite.jl#L175-L207">source</a></section><section><div><pre><code class="language-julia hljs">transaction(f::Function, conn::PostgreSQLConnection) -&gt; result</code></pre><p>Execute a function within a PostgreSQL transaction.</p><p>Uses BEGIN / COMMIT / ROLLBACK commands.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Function to execute. Receives PostgreSQLTransaction handle as argument.</li><li><code>conn</code>: PostgreSQL database connection</li></ul><p><strong>Returns</strong></p><p>The return value of the function <code>f</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">result = transaction(db) do tx
    execute(tx, &quot;INSERT INTO users (email) VALUES ($1)&quot;, [&quot;alice@example.com&quot;])
    execute(tx, &quot;INSERT INTO orders (user_id, total) VALUES ($1, $2)&quot;, [1, 100.0])
    return &quot;success&quot;
end</code></pre><p><strong>Implementation Details</strong></p><ul><li>BEGIN starts the transaction</li><li>COMMIT is executed if the function completes successfully</li><li>ROLLBACK is executed if an exception occurs</li><li>The transaction handle can be used with execute() and all query execution APIs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Drivers/postgresql.jl#L187-L219">source</a></section><section><div><pre><code class="language-julia hljs">transaction(f::Function, conn::Connection) -&gt; result</code></pre><p>Execute a function within a database transaction.</p><p>The transaction automatically commits if the function completes successfully, or rolls back if an exception is thrown.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Function to execute within the transaction. Receives transaction handle as argument.</li><li><code>conn</code>: Database connection</li></ul><p><strong>Returns</strong></p><p>The return value of the function <code>f</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Simple transaction
result = transaction(db) do tx
    execute(tx, &quot;INSERT INTO users (email) VALUES (?)&quot;, [&quot;alice@example.com&quot;])
    execute(tx, &quot;INSERT INTO orders (user_id, total) VALUES (?, ?)&quot;, [1, 100.0])
    return &quot;success&quot;
end
# result == &quot;success&quot;

# Transaction with query execution
users = transaction(db) do tx
    q = from(:users) |&gt;
        where(col(:users, :active) == literal(true)) |&gt;
        select(NamedTuple, col(:users, :id), col(:users, :email))

    fetch_all(tx, dialect, registry, q)
end
# users is Vector{NamedTuple}

# Transaction rollback on exception
try
    transaction(db) do tx
        execute(tx, &quot;INSERT INTO users (email) VALUES (?)&quot;, [&quot;alice@example.com&quot;])
        error(&quot;Something went wrong!&quot;)
        # Transaction is automatically rolled back
    end
catch e
    println(&quot;Transaction rolled back: &quot;, e)
end</code></pre><p><strong>Errors</strong></p><p>Rethrows any exception that occurs within the function <code>f</code> after rolling back the transaction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/transaction.jl#L57-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.savepoint"><a class="docstring-binding" href="#SQLSketch.Core.savepoint"><code>SQLSketch.Core.savepoint</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">savepoint(f::Function, tx::SQLiteTransaction, name::Symbol) -&gt; result</code></pre><p>Create a savepoint within a SQLite transaction for nested transaction semantics.</p><p>Uses SAVEPOINT / RELEASE / ROLLBACK TO commands.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Function to execute within the savepoint. Receives transaction handle.</li><li><code>tx</code>: SQLite transaction handle</li><li><code>name</code>: Unique name for the savepoint</li></ul><p><strong>Returns</strong></p><p>The return value of the function <code>f</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">transaction(db) do tx
    execute_sql(tx, &quot;INSERT INTO users (email) VALUES (?)&quot;, [&quot;alice@example.com&quot;])

    savepoint(tx, :sp1) do sp
        execute_sql(sp, &quot;INSERT INTO orders (user_id, total) VALUES (?, ?)&quot;, [1, 100.0])
        # Rolls back to sp1 if error occurs
    end
end</code></pre><p><strong>Implementation Details</strong></p><ul><li>SAVEPOINT creates a new savepoint on the transaction stack</li><li>RELEASE removes the savepoint on success</li><li>ROLLBACK TO restores database state to the savepoint, then RELEASE removes it</li><li>Savepoints can be nested</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Drivers/sqlite.jl#L274-L310">source</a></section><section><div><pre><code class="language-julia hljs">savepoint(f::Function, tx::PostgreSQLTransaction, name::Symbol) -&gt; result</code></pre><p>Create a savepoint within a PostgreSQL transaction.</p><p>Uses SAVEPOINT / RELEASE / ROLLBACK TO commands.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Function to execute within the savepoint</li><li><code>tx</code>: PostgreSQL transaction handle</li><li><code>name</code>: Unique name for the savepoint</li></ul><p><strong>Returns</strong></p><p>The return value of the function <code>f</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">transaction(db) do tx
    execute_sql(tx, &quot;INSERT INTO users (email) VALUES ($1)&quot;, [&quot;alice@example.com&quot;])

    savepoint(tx, :sp1) do sp
        execute_sql(sp, &quot;INSERT INTO orders (user_id, total) VALUES ($1, $2)&quot;, [1, 100.0])
        # Rolls back to sp1 if error occurs
    end
end</code></pre><p><strong>Implementation Details</strong></p><ul><li>SAVEPOINT creates a new savepoint on the transaction stack</li><li>RELEASE removes the savepoint on success</li><li>ROLLBACK TO restores database state to the savepoint</li><li>Savepoints can be nested</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Drivers/postgresql.jl#L285-L321">source</a></section><section><div><pre><code class="language-julia hljs">savepoint(f::Function, tx::TransactionHandle, name::Symbol) -&gt; result</code></pre><p>Create a savepoint within a transaction for nested transaction semantics.</p><p>Savepoints allow partial rollback: if an exception occurs within the savepoint, only changes made within that savepoint are rolled back. The outer transaction can still commit.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Function to execute within the savepoint. Receives transaction handle.</li><li><code>tx</code>: Transaction handle (from outer <code>transaction()</code> call)</li><li><code>name</code>: Unique name for the savepoint</li></ul><p><strong>Returns</strong></p><p>The return value of the function <code>f</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">transaction(db) do tx
    # This insert is in the outer transaction
    execute(tx, &quot;INSERT INTO users (email) VALUES (?)&quot;, [&quot;alice@example.com&quot;])

    # Savepoint for risky operation
    try
        savepoint(tx, :risky_operation) do sp
            execute(sp, &quot;INSERT INTO orders (user_id, total) VALUES (?, ?)&quot;, [1, 100.0])
            # Some risky operation that might fail
            if some_condition
                error(&quot;Risky operation failed!&quot;)
            end
        end
    catch e
        # Orders insert was rolled back, but users insert will still commit
        println(&quot;Savepoint rolled back: &quot;, e)
    end

    # User insert still commits
end

# Multiple savepoints
transaction(db) do tx
    execute(tx, &quot;INSERT INTO users (email) VALUES (?)&quot;, [&quot;alice@example.com&quot;])

    savepoint(tx, :sp1) do sp1
        execute(sp1, &quot;INSERT INTO orders (user_id, total) VALUES (?, ?)&quot;, [1, 100.0])

        savepoint(sp1, :sp2) do sp2
            execute(sp2, &quot;INSERT INTO order_items (order_id, sku) VALUES (?, ?)&quot;,
                    [1, &quot;ABC123&quot;])
        end
    end
end</code></pre><p><strong>Errors</strong></p><p>Rethrows any exception that occurs within the function <code>f</code> after rolling back to the savepoint.</p><p><strong>Notes</strong></p><ul><li>Savepoints can be nested</li><li>Savepoint names must be unique within a transaction</li><li>SQLite uses SAVEPOINT/RELEASE/ROLLBACK TO commands</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/transaction.jl#L116-L184">source</a></section></details></article><h2 id="SQL-Generation"><a class="docs-heading-anchor" href="#SQL-Generation">SQL Generation</a><a id="SQL-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#SQL-Generation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SQLSketch.Core.sql"><a class="docstring-binding" href="#SQLSketch.Core.sql"><code>SQLSketch.Core.sql</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sql(dialect::Dialect, query::Query) -&gt; String</code></pre><p>Generate SQL string from a query for inspection (without executing).</p><p><strong>Arguments</strong></p><ul><li><code>dialect</code>: SQL dialect for compilation</li><li><code>query</code>: Query AST to compile</li></ul><p><strong>Returns</strong></p><p>SQL string (with parameter placeholders)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:users) |&gt;
    where(col(:users, :age) &gt; param(Int, :min_age)) |&gt;
    select(NamedTuple, col(:users, :name))

sql_str = sql(dialect, q)
# → &quot;SELECT `name` FROM `users` WHERE `age` &gt; ?&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/execute.jl#L357-L381">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.compile"><a class="docstring-binding" href="#SQLSketch.Core.compile"><code>SQLSketch.Core.compile</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compile(dialect::Dialect, query::Query) -&gt; (sql::String, params::Vector{Symbol})</code></pre><p>Compile a Query AST into a SQL string and parameter list.</p><p><strong>Arguments</strong></p><ul><li><code>dialect</code>: The SQL dialect to use for compilation</li><li><code>query</code>: The query AST to compile</li></ul><p><strong>Returns</strong></p><ul><li><code>sql</code>: The generated SQL string</li><li><code>params</code>: A vector of parameter names in the order they appear in the SQL</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:users) |&gt; where(col(:users, :id) == param(Int, :user_id))
sql, params = compile(SQLiteDialect(), q)
# sql    → &quot;SELECT * FROM `users` WHERE `users`.`id` = ?&quot;
# params → [:user_id]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/dialect.jl#L82-L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.explain"><a class="docstring-binding" href="#SQLSketch.Core.explain"><code>SQLSketch.Core.explain</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">explain(conn::Connection, dialect::Dialect, query::Query) -&gt; String</code></pre><p>Execute EXPLAIN on a query and return the query plan.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Database connection</li><li><code>dialect</code>: SQL dialect for compilation</li><li><code>query</code>: Query AST to explain</li></ul><p><strong>Returns</strong></p><p>EXPLAIN output as a string</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:users) |&gt;
    where(col(:users, :age) &gt; literal(25)) |&gt;
    select(NamedTuple, col(:users, :name))

plan = explain(db, dialect, q)
# → EXPLAIN output</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Core/execute.jl#L387-L412">source</a></section></details></article><h2 id="Dialects"><a class="docs-heading-anchor" href="#Dialects">Dialects</a><a id="Dialects-1"></a><a class="docs-heading-anchor-permalink" href="#Dialects" title="Permalink"></a></h2><p>SQLSketch provides dialect abstraction for different SQL databases:</p><ul><li><strong>SQLiteDialect</strong> - SQLite SQL generation</li><li><strong>PostgreSQLDialect</strong> - PostgreSQL SQL generation</li></ul><p>Each dialect handles:</p><ul><li>Identifier quoting (<code>&quot;identifier&quot;</code> for PostgreSQL, <span>$`identifier`$</span> for SQLite)</li><li>Placeholder syntax (<code>$1, $2, ...</code> for PostgreSQL, <code>?, ?, ...</code> for SQLite)</li><li>Type mapping and casting</li><li>SQL feature capabilities (RETURNING, ON CONFLICT, etc.)</li></ul><h2 id="Drivers"><a class="docs-heading-anchor" href="#Drivers">Drivers</a><a id="Drivers-1"></a><a class="docs-heading-anchor-permalink" href="#Drivers" title="Permalink"></a></h2><p>SQLSketch provides driver abstraction for database connections:</p><ul><li><strong>SQLiteDriver</strong> - SQLite database driver (in-memory or file-based)</li><li><strong>PostgreSQLDriver</strong> - PostgreSQL database driver (via LibPQ.jl)</li></ul><p>Each driver handles:</p><ul><li>Connection management</li><li>Query execution</li><li>Transaction support</li><li>Parameter binding</li><li>Result mapping</li></ul><h2 id="Migration-System"><a class="docs-heading-anchor" href="#Migration-System">Migration System</a><a id="Migration-System-1"></a><a class="docs-heading-anchor-permalink" href="#Migration-System" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SQLSketch.Extras.apply_migrations"><a class="docstring-binding" href="#SQLSketch.Extras.apply_migrations"><code>SQLSketch.Extras.apply_migrations</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">apply_migrations(conn::Connection, dialect::Dialect, migrations_dir::String) -&gt; Vector{Migration}</code></pre><p>Apply all pending migrations from a directory.</p><p>Discovers all migrations in the directory, identifies which have not been applied, and applies them in order (oldest first). Each migration runs in its own transaction.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Database connection</li><li><code>dialect</code>: SQL dialect</li><li><code>migrations_dir</code>: Path to directory containing migration files</li></ul><p><strong>Returns</strong></p><p>Vector of migrations that were applied (empty if all migrations were already applied)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">applied = apply_migrations(conn, dialect, &quot;db/migrations&quot;)
println(&quot;Applied $(length(applied)) migrations&quot;)</code></pre><p><strong>Errors</strong></p><ul><li>Throws error if migration directory doesn&#39;t exist</li><li>Throws error if any migration fails (already-applied migrations are not rolled back)</li><li>Throws error if applied migration checksum doesn&#39;t match file checksum (modification detected)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Extras/migrations.jl#L486-L516">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Extras.migration_status"><a class="docstring-binding" href="#SQLSketch.Extras.migration_status"><code>SQLSketch.Extras.migration_status</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">migration_status(conn::Connection, dialect::Dialect, migrations_dir::String) -&gt; Vector{MigrationStatus}</code></pre><p>Get the status of all migrations (applied and pending).</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Database connection</li><li><code>dialect</code>: SQL dialect</li><li><code>migrations_dir</code>: Path to directory containing migration files</li></ul><p><strong>Returns</strong></p><p>Vector of MigrationStatus structs, sorted by version (oldest first)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">status = migration_status(conn, dialect, &quot;db/migrations&quot;)
for s in status
    applied_str = s.applied ? &quot;✓&quot; : &quot;✗&quot;
    println(&quot;$applied_str $(s.migration.version) $(s.migration.name)&quot;)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/8e2c1748824cf9c1dea6b3b505fdc526c1ae9d7b/src/Extras/migrations.jl#L551-L575">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../design/">Design »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 20 December 2025 14:51">Saturday 20 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
