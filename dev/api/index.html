<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · SQLSketch.jl</title><meta name="title" content="API Reference · SQLSketch.jl"/><meta property="og:title" content="API Reference · SQLSketch.jl"/><meta property="twitter:title" content="API Reference · SQLSketch.jl"/><meta name="description" content="Documentation for SQLSketch.jl."/><meta property="og:description" content="Documentation for SQLSketch.jl."/><meta property="twitter:description" content="Documentation for SQLSketch.jl."/><meta property="og:url" content="https://daikichiba9511.github.io/SQLSketch.jl/api/"/><meta property="twitter:url" content="https://daikichiba9511.github.io/SQLSketch.jl/api/"/><link rel="canonical" href="https://daikichiba9511.github.io/SQLSketch.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SQLSketch.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Query-Building"><span>Query Building</span></a></li><li><a class="tocitem" href="#DML-Operations"><span>DML Operations</span></a></li><li><a class="tocitem" href="#DDL-Operations"><span>DDL Operations</span></a></li><li><a class="tocitem" href="#Expressions"><span>Expressions</span></a></li><li><a class="tocitem" href="#Query-Execution"><span>Query Execution</span></a></li><li><a class="tocitem" href="#SQL-Generation"><span>SQL Generation</span></a></li><li><a class="tocitem" href="#Metadata-API"><span>Metadata API</span></a></li><li><a class="tocitem" href="#Dialects"><span>Dialects</span></a></li><li><a class="tocitem" href="#Drivers"><span>Drivers</span></a></li><li><a class="tocitem" href="#Migration-System"><span>Migration System</span></a></li><li><a class="tocitem" href="#Connection-Pooling"><span>Connection Pooling</span></a></li></ul></li><li><a class="tocitem" href="../design/">Design</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/main/docs/src/api.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Query-Building"><a class="docs-heading-anchor" href="#Query-Building">Query Building</a><a id="Query-Building-1"></a><a class="docs-heading-anchor-permalink" href="#Query-Building" title="Permalink"></a></h2><h3 id="Starting-Queries"><a class="docs-heading-anchor" href="#Starting-Queries">Starting Queries</a><a id="Starting-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Starting-Queries" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.from"><a class="docstring-binding" href="#SQLSketch.Core.from"><code>SQLSketch.Core.from</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">from(table::Symbol) -&gt; From{NamedTuple}</code></pre><p>Creates a FROM clause as the starting point of a query.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:users)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/query.jl#L292-L302">source</a></section></details></article><h3 id="Filtering-and-Conditions"><a class="docs-heading-anchor" href="#Filtering-and-Conditions">Filtering and Conditions</a><a id="Filtering-and-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering-and-Conditions" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.where"><a class="docstring-binding" href="#SQLSketch.Core.where"><code>SQLSketch.Core.where</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">where(q, condition)</code></pre><p>Adds a WHERE clause to filter rows.</p><p>This is a <strong>shape-preserving</strong> operation.</p><p>Can be used in two ways:</p><ul><li>Explicit: <code>where(query, condition)</code></li><li>Pipeline: <code>query |&gt; where(condition)</code></li></ul><p>The curried form <code>where(condition)</code> returns a function suitable for pipeline composition.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Pipeline style
q = from(:users) |&gt; where(col(:users, :active) == literal(true))

# Explicit style
q = where(from(:users), col(:users, :active) == literal(true))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/query.jl#L307-L330">source</a></section><section><div><pre><code class="language-julia hljs">where(source::UpdateSet{T}, condition::SQLExpr) -&gt; UpdateWhere{T}</code></pre><p>Add WHERE clause to UPDATE (explicit version).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/query.jl#L919-L923">source</a></section><section><div><pre><code class="language-julia hljs">where(source::DeleteFrom{T}, condition::SQLExpr) -&gt; DeleteWhere{T}</code></pre><p>Add WHERE clause to DELETE (explicit version).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/query.jl#L942-L946">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.having"><a class="docstring-binding" href="#SQLSketch.Core.having"><code>SQLSketch.Core.having</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">having(q::Query{T}, condition::SQLExpr)::Having{T}</code></pre><p>Adds a HAVING clause (used with GROUP BY).</p><p>This is a <strong>shape-preserving</strong> operation.</p><p>Can be used in two ways:</p><ul><li>Explicit: <code>having(query, condition)</code></li><li>Pipeline: <code>query |&gt; having(condition)</code></li></ul><p>The curried form <code>having(condition)</code> returns a function suitable for pipeline composition.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:orders) |&gt;
    group_by(col(:orders, :user_id)) |&gt;
    having(func(:COUNT, [col(:orders, :id)]) &gt; literal(5))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/query.jl#L502-L523">source</a></section></details></article><h3 id="Selecting-Columns"><a class="docs-heading-anchor" href="#Selecting-Columns">Selecting Columns</a><a id="Selecting-Columns-1"></a><a class="docs-heading-anchor-permalink" href="#Selecting-Columns" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.select"><a class="docstring-binding" href="#SQLSketch.Core.select"><code>SQLSketch.Core.select</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">select(q::Query, OutT::Type, fields::SQLExpr...) -&gt; Select{OutT}</code></pre><p>Adds a SELECT clause to project specific columns.</p><p>This is the <strong>only shape-changing</strong> operation – it changes the output type to <code>OutT</code>.</p><p>Can be used in two ways:</p><ul><li>Explicit: <code>select(query, OutT, fields...)</code></li><li>Pipeline: <code>query |&gt; select(OutT, fields...)</code></li></ul><p>The curried form <code>select(OutT, fields...)</code> returns a function suitable for pipeline composition.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Pipeline style
q = from(:users) |&gt; select(NamedTuple, col(:users, :id), col(:users, :email))

# Explicit style
q = select(from(:users), NamedTuple, col(:users, :id), col(:users, :email))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/query.jl#L338-L361">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.distinct"><a class="docstring-binding" href="#SQLSketch.Core.distinct"><code>SQLSketch.Core.distinct</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">distinct(q::Query{T}) -&gt; Distinct{T}</code></pre><p>Adds a DISTINCT clause.</p><p>This is a <strong>shape-preserving</strong> operation.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:users) |&gt; select(NamedTuple, col(:users, :email)) |&gt; distinct</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/query.jl#L458-L470">source</a></section></details></article><h3 id="Ordering-and-Limiting"><a class="docs-heading-anchor" href="#Ordering-and-Limiting">Ordering and Limiting</a><a id="Ordering-and-Limiting-1"></a><a class="docs-heading-anchor-permalink" href="#Ordering-and-Limiting" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.order_by"><a class="docstring-binding" href="#SQLSketch.Core.order_by"><code>SQLSketch.Core.order_by</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">order_by(q::Query{T}, field::SQLExpr; desc::Bool=false)::OrderBy{T}</code></pre><p>Adds an ORDER BY clause.</p><p>This is a <strong>shape-preserving</strong> operation.</p><p>Can be used in two ways:</p><ul><li>Explicit: <code>order_by(query, field, desc=false)</code></li><li>Pipeline: <code>query |&gt; order_by(field, desc=false)</code></li></ul><p>The curried form <code>order_by(field; desc=false)</code> returns a function suitable for pipeline composition.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Pipeline style
q = from(:users) |&gt; order_by(col(:users, :created_at); desc = true)

# Explicit style
q = order_by(from(:users), col(:users, :created_at); desc = true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/query.jl#L368-L391">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.limit"><a class="docstring-binding" href="#SQLSketch.Core.limit"><code>SQLSketch.Core.limit</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">limit(q::Query{T}, n::Int)::Limit{T}</code></pre><p>Adds a LIMIT clause.</p><p>This is a <strong>shape-preserving</strong> operation.</p><p>Can be used in two ways:</p><ul><li>Explicit: <code>limit(query, n)</code></li><li>Pipeline: <code>query |&gt; limit(n)</code></li></ul><p>The curried form <code>limit(n)</code> returns a function suitable for pipeline composition.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:users) |&gt; limit(10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/query.jl#L404-L423">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.offset"><a class="docstring-binding" href="#SQLSketch.Core.offset"><code>SQLSketch.Core.offset</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">offset(q::Query{T}, n::Int)::Offset{T}</code></pre><p>Adds an OFFSET clause.</p><p>This is a <strong>shape-preserving</strong> operation.</p><p>Can be used in two ways:</p><ul><li>Explicit: <code>offset(query, n)</code></li><li>Pipeline: <code>query |&gt; offset(n)</code></li></ul><p>The curried form <code>offset(n)</code> returns a function suitable for pipeline composition.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:users) |&gt; offset(20)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/query.jl#L431-L450">source</a></section></details></article><h3 id="Grouping"><a class="docs-heading-anchor" href="#Grouping">Grouping</a><a id="Grouping-1"></a><a class="docs-heading-anchor-permalink" href="#Grouping" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.group_by"><a class="docstring-binding" href="#SQLSketch.Core.group_by"><code>SQLSketch.Core.group_by</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">group_by(q::Query{T}, fields::SQLExpr...)::GroupBy{T}</code></pre><p>Adds a GROUP BY clause.</p><p>This is a <strong>shape-preserving</strong> operation.</p><p>Can be used in two ways:</p><ul><li>Explicit: <code>group_by(query, fields...)</code></li><li>Pipeline: <code>query |&gt; group_by(fields...)</code></li></ul><p>The curried form <code>group_by(fields...)</code> returns a function suitable for pipeline composition.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:orders) |&gt; group_by(col(:orders, :user_id))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/query.jl#L475-L494">source</a></section></details></article><h2 id="DML-Operations"><a class="docs-heading-anchor" href="#DML-Operations">DML Operations</a><a id="DML-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#DML-Operations" title="Permalink"></a></h2><h3 id="INSERT"><a class="docs-heading-anchor" href="#INSERT">INSERT</a><a id="INSERT-1"></a><a class="docs-heading-anchor-permalink" href="#INSERT" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.insert_into"><a class="docstring-binding" href="#SQLSketch.Core.insert_into"><code>SQLSketch.Core.insert_into</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">insert_into(table::Symbol, columns::Vector{Symbol}) -&gt; InsertInto{NamedTuple}</code></pre><p>Create an INSERT INTO clause.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = insert_into(:users, [:name, :email]) |&gt;
    values([[literal(&quot;Alice&quot;), literal(&quot;alice@example.com&quot;)]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/query.jl#L822-L833">source</a></section></details></article><h3 id="Batch-INSERT"><a class="docs-heading-anchor" href="#Batch-INSERT">Batch INSERT</a><a id="Batch-INSERT-1"></a><a class="docs-heading-anchor-permalink" href="#Batch-INSERT" title="Permalink"></a></h3><p>For efficient insertion of large datasets, use <code>insert_batch</code>:</p><article><details class="docstring" open="true"><summary id="SQLSketch.Core.insert_batch"><a class="docstring-binding" href="#SQLSketch.Core.insert_batch"><code>SQLSketch.Core.insert_batch</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">insert_batch(conn::Connection,
             dialect::Dialect,
             registry::CodecRegistry,
             table::Symbol,
             columns::Vector{Symbol},
             rows::Vector{&lt;:NamedTuple};
             chunk_size::Int = 1000) -&gt; ExecResult</code></pre><p>Insert multiple rows into a table using the most efficient method available.</p><p>Automatically selects the optimal insertion strategy:</p><ul><li><strong>PostgreSQL with CAP<em>BULK</em>COPY</strong>: Uses COPY FROM STDIN (fastest)</li><li><strong>Other databases</strong>: Uses multi-row INSERT VALUES (fast)</li></ul><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Active database connection</li><li><code>dialect</code>: Dialect for SQL generation</li><li><code>registry</code>: CodecRegistry for value encoding</li><li><code>table</code>: Target table name</li><li><code>columns</code>: Column names to insert (must match NamedTuple keys)</li><li><code>rows</code>: Vector of NamedTuples containing row data</li><li><code>chunk_size</code>: Number of rows per transaction (default: 1000)</li></ul><p><strong>Returns</strong></p><ul><li><code>ExecResult</code> with rows_affected count</li></ul><p><strong>Performance</strong></p><p><strong>PostgreSQL COPY (CAP<em>BULK</em>COPY):</strong></p><ul><li>50K-100K rows/sec</li><li>Ideal for &gt;10K rows</li><li>Binary protocol (minimal overhead)</li></ul><p><strong>Standard Batch INSERT:</strong></p><ul><li>5K-20K rows/sec</li><li>Ideal for &lt;10K rows</li><li>Multi-row VALUES clause</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using SQLSketch

# Connect
conn = connect(PostgreSQLDriver(), &quot;postgresql://localhost/mydb&quot;)
dialect = PostgreSQLDialect()
registry = CodecRegistry()

# Prepare data
users = [(id = 1, email = &quot;alice@example.com&quot;, active = true),
         (id = 2, email = &quot;bob@example.com&quot;, active = true)
         # ... 100K more rows
         ]

# Batch insert (automatically uses COPY for PostgreSQL)
result = insert_batch(conn, dialect, registry, :users, [:id, :email, :active], users)
println(&quot;Inserted $(result.rows_affected) rows&quot;)</code></pre><p><strong>Implementation Details</strong></p><p>The function detects PostgreSQL connections with COPY support:</p><pre><code class="language-julia hljs">if supports(dialect, CAP_BULK_COPY) &amp;&amp; conn isa PostgreSQLConnection
    # Fast path: PostgreSQL COPY
    _insert_batch_copy(conn, dialect, registry, table, columns, rows)
else
    # Standard path: Multi-row INSERT
    _insert_batch_standard(conn, dialect, registry, table, columns, rows, chunk_size)
end</code></pre><p><strong>Error Handling</strong></p><ul><li>Each chunk runs in a transaction</li><li>Rollback on failure (no partial chunks)</li><li>Error message includes failing row index</li></ul><p><strong>Chunking</strong></p><p>Large batches are automatically split into chunks:</p><ul><li>Default: 1000 rows per chunk</li><li>Each chunk = separate transaction</li><li>Total rows_affected = sum of all chunks</li></ul><p><strong>Type Safety</strong></p><p>All values are encoded using the CodecRegistry:</p><ul><li>Automatic type conversion</li><li>NULL/Missing handling</li><li>Type validation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/batch.jl#L49-L149">source</a></section></details></article><p><strong>Performance:</strong></p><ul><li><strong>SQLite:</strong> 1.35x - 299x faster than loop INSERT</li><li><strong>PostgreSQL:</strong> 4x - 2016x faster (uses COPY FROM STDIN)</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs"># Prepare data
users = [
    (id=1, email=&quot;alice@example.com&quot;, active=true),
    (id=2, email=&quot;bob@example.com&quot;, active=true),
    # ... thousands more
]

# Batch insert (automatically optimized)
result = insert_batch(conn, dialect, registry, :users,
                      [:id, :email, :active], users)
println(&quot;Inserted $(result.rowcount) rows&quot;)</code></pre><p>See <code>benchmark/RESULTS.md</code> in the repository for detailed performance analysis.</p><h3 id="UPDATE"><a class="docs-heading-anchor" href="#UPDATE">UPDATE</a><a id="UPDATE-1"></a><a class="docs-heading-anchor-permalink" href="#UPDATE" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.update"><a class="docstring-binding" href="#SQLSketch.Core.update"><code>SQLSketch.Core.update</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">update(table::Symbol) -&gt; Update{NamedTuple}</code></pre><p>Create an UPDATE statement.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = update(:users) |&gt;
    set(:name =&gt; param(String, :name)) |&gt;
    where(col(:users, :id) == param(Int, :id))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/query.jl#L875-L887">source</a></section></details></article><h3 id="DELETE"><a class="docs-heading-anchor" href="#DELETE">DELETE</a><a id="DELETE-1"></a><a class="docs-heading-anchor-permalink" href="#DELETE" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.delete_from"><a class="docstring-binding" href="#SQLSketch.Core.delete_from"><code>SQLSketch.Core.delete_from</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">delete_from(table::Symbol) -&gt; DeleteFrom{NamedTuple}</code></pre><p>Create a DELETE FROM statement.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = delete_from(:users) |&gt;
    where(col(:users, :id) == param(Int, :id))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/query.jl#L928-L939">source</a></section></details></article><h3 id="RETURNING"><a class="docs-heading-anchor" href="#RETURNING">RETURNING</a><a id="RETURNING-1"></a><a class="docs-heading-anchor-permalink" href="#RETURNING" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.returning"><a class="docstring-binding" href="#SQLSketch.Core.returning"><code>SQLSketch.Core.returning</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">returning(q::Query, OutT::Type, fields...)::Returning{OutT}</code></pre><p>Add a RETURNING clause to a DML operation.</p><p>This is a shape-changing operation that transforms a DML query into a query that returns typed results from the affected rows.</p><p><strong>Arguments</strong></p><ul><li><code>q</code>: DML query (InsertValues, UpdateSet, UpdateWhere, DeleteFrom, or DeleteWhere)</li><li><code>OutT</code>: Output type (typically NamedTuple or a struct type)</li><li><code>fields...</code>: Expressions for fields to return</li></ul><p><strong>Returns</strong></p><p>A <code>Returning{OutT}</code> query node</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Basic RETURNING with placeholder syntax
q = insert_into(:users, [:email]) |&gt;
    values([[literal(&quot;test@example.com&quot;)]]) |&gt;
    returning(NamedTuple, p_.id, p_.email)

# RETURNING with explicit column references
q = update(:users) |&gt;
    set(:status =&gt; literal(&quot;active&quot;)) |&gt;
    where(col(:users, :id) == param(Int, :id)) |&gt;
    returning(NamedTuple, col(:users, :id), col(:users, :status))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/query.jl#L1041-L1073">source</a></section><section><div><pre><code class="language-julia hljs">returning(OutT::Type, fields...)</code></pre><p>Curried version of <code>returning</code> for pipeline composition.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = insert_into(:users, [:email]) |&gt;
    values([[literal(&quot;test@example.com&quot;)]]) |&gt;
    returning(NamedTuple, p_.id, p_.email)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/query.jl#L1078-L1090">source</a></section></details></article><h2 id="DDL-Operations"><a class="docs-heading-anchor" href="#DDL-Operations">DDL Operations</a><a id="DDL-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#DDL-Operations" title="Permalink"></a></h2><h3 id="Table-Operations"><a class="docs-heading-anchor" href="#Table-Operations">Table Operations</a><a id="Table-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Table-Operations" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.create_table"><a class="docstring-binding" href="#SQLSketch.Core.create_table"><code>SQLSketch.Core.create_table</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_table(table::Symbol; if_not_exists::Bool=false, temporary::Bool=false) -&gt; CreateTable</code></pre><p>Create a CREATE TABLE statement.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">create_table(:users)
create_table(:users; if_not_exists = true)
create_table(:temp_data; temporary = true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/ddl.jl#L742-L754">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.alter_table"><a class="docstring-binding" href="#SQLSketch.Core.alter_table"><code>SQLSketch.Core.alter_table</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">alter_table(table::Symbol) -&gt; AlterTable</code></pre><p>Create an ALTER TABLE statement.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">alter_table(:users) |&gt;
add_alter_column(:age, :integer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/ddl.jl#L1059-L1070">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.drop_table"><a class="docstring-binding" href="#SQLSketch.Core.drop_table"><code>SQLSketch.Core.drop_table</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">drop_table(table::Symbol; if_exists::Bool=false, cascade::Bool=false) -&gt; DropTable</code></pre><p>Create a DROP TABLE statement.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">drop_table(:users)
drop_table(:users; if_exists = true)
drop_table(:users; cascade = true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/ddl.jl#L1420-L1432">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.add_column"><a class="docstring-binding" href="#SQLSketch.Core.add_column"><code>SQLSketch.Core.add_column</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add_column(ct::CreateTable, name::Symbol, type::ColumnType;
           primary_key::Bool=false, nullable::Bool=true, unique::Bool=false,
           default::Union{SQLExpr, Nothing}=nothing,
           references::Union{Tuple{Symbol, Symbol}, Nothing}=nothing,
           check::Union{SQLExpr, Nothing}=nothing,
           auto_increment::Bool=false,
           generated::Union{SQLExpr, Nothing}=nothing,
           stored::Bool=true,
           collation::Union{Symbol, Nothing}=nothing,
           on_update::Union{SQLExpr, Nothing}=nothing,
           comment::Union{String, Nothing}=nothing,
           identity::Bool=false,
           identity_always::Bool=false,
           identity_start::Union{Int, Nothing}=nothing,
           identity_increment::Union{Int, Nothing}=nothing) -&gt; CreateTable</code></pre><p>Add a column to a CREATE TABLE statement.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>primary_key::Bool</code> – Mark as PRIMARY KEY</li><li><code>nullable::Bool</code> – Allow NULL values (default true)</li><li><code>unique::Bool</code> – Add UNIQUE constraint</li><li><code>default::Union{SQLExpr, Nothing}</code> – Default value expression</li><li><code>references::Union{Tuple{Symbol, Symbol}, Nothing}</code> – Foreign key reference (table, column)</li><li><code>check::Union{SQLExpr, Nothing}</code> – Column-level CHECK constraint</li><li><code>auto_increment::Bool</code> – AUTO_INCREMENT / SERIAL (dialect-specific)</li><li><code>generated::Union{SQLExpr, Nothing}</code> – GENERATED column expression</li><li><code>stored::Bool</code> – STORED (true) or VIRTUAL (false) for GENERATED columns</li><li><code>collation::Union{Symbol, Nothing}</code> – COLLATE clause for string columns</li><li><code>on_update::Union{SQLExpr, Nothing}</code> – ON UPDATE clause (MySQL)</li><li><code>comment::Union{String, Nothing}</code> – Column comment</li><li><code>identity::Bool</code> – IDENTITY column (PostgreSQL)</li><li><code>identity_always::Bool</code> – ALWAYS (true) or BY DEFAULT (false) for IDENTITY</li><li><code>identity_start::Union{Int, Nothing}</code> – Starting value for IDENTITY</li><li><code>identity_increment::Union{Int, Nothing}</code> – Increment value for IDENTITY</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">create_table(:users) |&gt;
add_column(:id, :integer; primary_key = true, auto_increment = true) |&gt;
add_column(:email, :text; nullable = false, unique = true, collation = :nocase) |&gt;
add_column(:age, :integer; check = col(:users, :age) &gt;= literal(0)) |&gt;
add_column(:created_at, :timestamp; default = literal(:current_timestamp))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/ddl.jl#L761-L808">source</a></section><section><div><pre><code class="language-julia hljs">add_column(name::Symbol, type::ColumnType; kwargs...) -&gt; Function</code></pre><p>Curried version of <code>add_column</code> for pipeline composition.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">create_table(:users) |&gt;
add_column(:id, :integer; primary_key = true, auto_increment = true) |&gt;
add_column(:email, :text; nullable = false, collation = :nocase)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/ddl.jl#L887-L899">source</a></section></details></article><h3 id="Index-Operations"><a class="docs-heading-anchor" href="#Index-Operations">Index Operations</a><a id="Index-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Index-Operations" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.create_index"><a class="docstring-binding" href="#SQLSketch.Core.create_index"><code>SQLSketch.Core.create_index</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_index(name::Symbol, table::Symbol, columns::Vector{Symbol};
             unique::Bool=false, if_not_exists::Bool=false,
             where::Union{SQLExpr, Nothing}=nothing,
             expr::Union{Vector{SQLExpr}, Nothing}=nothing,
             method::Union{Symbol, Nothing}=nothing) -&gt; CreateIndex</code></pre><p>Create a CREATE INDEX statement.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>unique::Bool</code> – Create a unique index</li><li><code>if_not_exists::Bool</code> – Include IF NOT EXISTS clause</li><li><code>where::Union{SQLExpr, Nothing}</code> – Partial index condition</li><li><code>expr::Union{Vector{SQLExpr}, Nothing}</code> – Expression index (mutually exclusive with columns)</li><li><code>method::Union{Symbol, Nothing}</code> – Index method (:btree, :hash, :gin, :gist, :brin, :spgist) - PostgreSQL only</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Column index
create_index(:idx_users_email, :users, [:email])
create_index(:idx_users_email, :users, [:email]; unique = true)

# Partial index
create_index(:idx_active_users, :users, [:id];
             where = col(:users, :active) == literal(true))

# Expression index
create_index(:idx_users_lower_email, :users, Symbol[];
             expr = [func(:lower, [col(:users, :email)])])

# Index with method (PostgreSQL)
create_index(:idx_users_tags, :users, [:tags]; method = :gin)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/ddl.jl#L1442-L1477">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.drop_index"><a class="docstring-binding" href="#SQLSketch.Core.drop_index"><code>SQLSketch.Core.drop_index</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">drop_index(name::Symbol; if_exists::Bool=false) -&gt; DropIndex</code></pre><p>Create a DROP INDEX statement.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">drop_index(:idx_users_email)
drop_index(:idx_users_email; if_exists = true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/ddl.jl#L1514-L1525">source</a></section></details></article><h2 id="Expressions"><a class="docs-heading-anchor" href="#Expressions">Expressions</a><a id="Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Expressions" title="Permalink"></a></h2><h3 id="Column-References"><a class="docs-heading-anchor" href="#Column-References">Column References</a><a id="Column-References-1"></a><a class="docs-heading-anchor-permalink" href="#Column-References" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.col"><a class="docstring-binding" href="#SQLSketch.Core.col"><code>SQLSketch.Core.col</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">col(table::Symbol, column::Symbol) -&gt; ColRef</code></pre><p>Convenience constructor for column references.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/expr.jl#L68-L72">source</a></section></details></article><h3 id="Literals-and-Parameters"><a class="docs-heading-anchor" href="#Literals-and-Parameters">Literals and Parameters</a><a id="Literals-and-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Literals-and-Parameters" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.literal"><a class="docstring-binding" href="#SQLSketch.Core.literal"><code>SQLSketch.Core.literal</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">literal(value::Any) -&gt; Literal</code></pre><p>Convenience constructor for literal values. Accepts any Julia value to be embedded as a literal in SQL.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/expr.jl#L95-L100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.param"><a class="docstring-binding" href="#SQLSketch.Core.param"><code>SQLSketch.Core.param</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">param(T::Type, name::Symbol) -&gt; Param</code></pre><p>Convenience constructor for bound parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/expr.jl#L129-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Extras.p_"><a class="docstring-binding" href="#SQLSketch.Extras.p_"><code>SQLSketch.Extras.p_</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const p_ = Placeholder()</code></pre><p>Global placeholder constant for convenient field access.</p><p>Note: Uses <code>p_</code> instead of <code>_</code> because Julia reserves underscore-only identifiers for write-only variables.</p><p><strong>Usage</strong></p><pre><code class="language-julia hljs">from(:users) |&gt;
where(p_.age &gt; literal(18)) |&gt;
select(NamedTuple, p_.id, p_.email)</code></pre><p>Internally, <code>p_.column</code> creates a <code>PlaceholderField(:column)</code> which is resolved to <code>ColRef(table, :column)</code> during query compilation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Extras/placeholder.jl#L96-L114">source</a></section></details></article><h3 id="Comparisons"><a class="docs-heading-anchor" href="#Comparisons">Comparisons</a><a id="Comparisons-1"></a><a class="docs-heading-anchor-permalink" href="#Comparisons" title="Permalink"></a></h3><p>Binary operators are overloaded for <code>SQLExpr</code>:</p><ul><li><code>==</code>, <code>!=</code> - Equality/inequality</li><li><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> - Comparison</li><li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> - Arithmetic</li><li><code>&amp;</code> (and), <code>|</code> (or) - Logical operators</li></ul><h3 id="Type-Conversion"><a class="docs-heading-anchor" href="#Type-Conversion">Type Conversion</a><a id="Type-Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Conversion" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.cast"><a class="docstring-binding" href="#SQLSketch.Core.cast"><code>SQLSketch.Core.cast</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cast(expr::SQLExpr, target_type::Symbol) -&gt; Cast</code></pre><p>Convenience constructor for type casting.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">cast(col(:users, :age), :TEXT)
# → CAST(users.age AS TEXT)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/expr.jl#L623-L634">source</a></section></details></article><h3 id="Subqueries"><a class="docs-heading-anchor" href="#Subqueries">Subqueries</a><a id="Subqueries-1"></a><a class="docs-heading-anchor-permalink" href="#Subqueries" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.subquery"><a class="docstring-binding" href="#SQLSketch.Core.subquery"><code>SQLSketch.Core.subquery</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">subquery(query) -&gt; Subquery</code></pre><p>Convenience constructor for subquery expressions.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">sq = subquery(from(:orders) |&gt; select(NamedTuple, col(:orders, :user_id)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/expr.jl#L681-L691">source</a></section></details></article><h2 id="Query-Execution"><a class="docs-heading-anchor" href="#Query-Execution">Query Execution</a><a id="Query-Execution-1"></a><a class="docs-heading-anchor-permalink" href="#Query-Execution" title="Permalink"></a></h2><p>SQLSketch separates <strong>data retrieval</strong> from <strong>side-effecting operations</strong>.</p><p><strong>Key distinction:</strong></p><ul><li>Use <strong><code>fetch_*</code></strong> when you want to <strong>retrieve data</strong> (SELECT, INSERT/UPDATE/DELETE with RETURNING)</li><li>Use <strong><code>execute</code></strong> when you want to <strong>produce side effects</strong> without retrieving data (INSERT, UPDATE, DELETE, CREATE TABLE, etc.)</li></ul><p><strong>Quick reference:</strong></p><table><tr><th style="text-align: right">Function</th><th style="text-align: right">Returns</th><th style="text-align: right">Use Case</th><th style="text-align: right">Performance</th></tr><tr><td style="text-align: right"><code>fetch_all(conn, query)</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Get all rows (row-based)</td><td style="text-align: right">Fast (40-155% overhead vs raw)</td></tr><tr><td style="text-align: right"><code>fetch_all_columnar(conn, query)</code></td><td style="text-align: right"><code>NamedTuple of Vectors</code></td><td style="text-align: right">Get all rows (columnar)</td><td style="text-align: right"><strong>Fastest (4-12% overhead vs raw)</strong></td></tr><tr><td style="text-align: right"><code>fetch_all_columnar(conn, query, ColumnarType)</code></td><td style="text-align: right"><code>ColumnarType</code></td><td style="text-align: right">Get all rows (type-safe columnar)</td><td style="text-align: right"><strong>Fastest + type-safe</strong></td></tr><tr><td style="text-align: right"><code>fetch_one(conn, query)</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Get exactly one row (error if 0 or &gt;1)</td><td style="text-align: right">-</td></tr><tr><td style="text-align: right"><code>fetch_maybe(conn, query)</code></td><td style="text-align: right"><code>Union{T, Nothing}</code></td><td style="text-align: right">Get optional row</td><td style="text-align: right">-</td></tr><tr><td style="text-align: right"><code>execute(conn, query)</code></td><td style="text-align: right"><code>Int64</code></td><td style="text-align: right">Perform side effects (returns affected row count)</td><td style="text-align: right">-</td></tr></table><p>See <a href="../design/#13-query-execution-model">Design - Query Execution Model</a> for detailed rationale.</p><h3 id="Fetching-Results"><a class="docs-heading-anchor" href="#Fetching-Results">Fetching Results</a><a id="Fetching-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Fetching-Results" title="Permalink"></a></h3><h4 id="Row-Based-API"><a class="docs-heading-anchor" href="#Row-Based-API">Row-Based API</a><a id="Row-Based-API-1"></a><a class="docs-heading-anchor-permalink" href="#Row-Based-API" title="Permalink"></a></h4><article><details class="docstring" open="true"><summary id="SQLSketch.Core.fetch_all"><a class="docstring-binding" href="#SQLSketch.Core.fetch_all"><code>SQLSketch.Core.fetch_all</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fetch_all(conn::PostgreSQLConnection,
          dialect::Dialect,
          registry::CodecRegistry,
          query::Query{T},
          params::NamedTuple = NamedTuple();
          use_prepared::Bool = true) -&gt; Vector{T}</code></pre><p>PostgreSQL-optimized version of fetch_all using DecodePlan and Prepared Statement Caching.</p><p>This specialization automatically uses two key optimizations:</p><ol><li><p><strong>DecodePlan Optimization</strong>: Pre-resolves column types and codecs</p><ul><li>15-19% faster execution</li><li>24-25% memory reduction</li><li>26% fewer allocations</li></ul></li><li><p><strong>Prepared Statement Caching</strong>: Caches compiled SQL statements</p><ul><li>10-20% faster for repeated queries</li><li>Reduced PostgreSQL server load</li><li>LRU eviction policy (default: 100 statements)</li></ul></li></ol><p>Combined, these optimizations provide 25-35% performance improvement.</p><p><strong>Performance (measured with DecodePlan only)</strong></p><ul><li>Simple SELECT (500 rows): 18.95% faster, 24.83% less memory</li><li>JOIN Query (1667 rows): 17.1% faster, 23.95% less memory</li><li>ORDER BY + LIMIT (10 rows): 11.34% faster, 25.17% less memory</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using SQLSketch

conn = connect(PostgreSQLDriver(), &quot;postgresql://localhost/mydb&quot;)
dialect = PostgreSQLDialect()
registry = PostgreSQLCodecRegistry()

q = from(:users) |&gt; select(NamedTuple, col(:users, :id), col(:users, :name))

# Automatically uses both DecodePlan and Prepared Statement Caching
users = fetch_all(conn, dialect, registry, q)

# Disable prepared statements if needed
users = fetch_all(conn, dialect, registry, q; use_prepared = false)</code></pre><p><strong>Implementation</strong></p><p>This function:</p><ol><li>Compiles the query to SQL</li><li>Checks prepared statement cache (if enabled)</li><li>Prepares statement on cache miss</li><li>Binds parameters</li><li>Executes the query (prepared or direct)</li><li>Creates a DecodePlan (pre-resolves column types and codecs)</li><li>Decodes all rows using the optimized path</li></ol><p>See <code>prepare_decode_plan</code> and <code>decode_rows</code> for DecodePlan implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Drivers/postgresql.jl#L897-L960">source</a></section><section><div><pre><code class="language-julia hljs">fetch_all(conn::PostgreSQLConnection,
          dialect::Dialect,
          registry::CodecRegistry,
          query::Query{T},
          params::NamedTuple = NamedTuple();
          use_prepared::Bool = true) -&gt; Vector{T}</code></pre><p>PostgreSQL-optimized fetch_all for user-defined struct types.</p><p>Uses the same columnar-via-conversion strategy as the NamedTuple version, providing 5-8x speedup over direct LibPQ row × col access.</p><p><strong>Performance</strong></p><p>Same performance characteristics as NamedTuple version:</p><ul><li>5.6-8.3x faster than direct LibPQ access</li><li>40-155% overhead vs. raw LibPQ (vs. 1,000%+ before)</li><li>86-87% memory reduction</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">struct User
    id::Int
    name::String
    email::String
end

q = from(:users) |&gt; select(User, col(:users, :id), col(:users, :name), col(:users, :email))
users = fetch_all(conn, dialect, registry, q)
# → Vector{User} (fast!)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Drivers/postgresql.jl#L980-L1014">source</a></section><section><div><pre><code class="language-julia hljs">fetch_all(conn::Connection, dialect::Dialect, registry::CodecRegistry,
          query::Query{T}, params::NamedTuple = NamedTuple();
          use_prepared::Bool = true) -&gt; Vector{T}</code></pre><p>Execute a query and fetch all rows.</p><p>Automatically uses prepared statements with caching if the driver supports them. Prepared statements are cached to eliminate redundant parsing/planning overhead.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Database connection</li><li><code>dialect</code>: SQL dialect for compilation</li><li><code>registry</code>: Codec registry for type conversion</li><li><code>query</code>: Query AST to execute</li><li><code>params</code>: Named parameters for the query (default: empty NamedTuple)</li><li><code>use_prepared</code>: Whether to use prepared statements if available (default: true)</li></ul><p><strong>Returns</strong></p><p>Vector of results of type T (where T is the query&#39;s output type)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:users) |&gt;
    where(col(:users, :age) &gt; param(Int, :min_age)) |&gt;
    select(NamedTuple, col(:users, :id), col(:users, :name))

results = fetch_all(db, dialect, registry, q, (min_age = 25,))
# → Vector{NamedTuple}
# Automatically uses prepared statements with caching

# Disable prepared statements for specific query
results = fetch_all(db, dialect, registry, q, (min_age = 25,); use_prepared = false)
# → Uses direct SQL execution</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/execute.jl#L145-L183">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.fetch_one"><a class="docstring-binding" href="#SQLSketch.Core.fetch_one"><code>SQLSketch.Core.fetch_one</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fetch_one(conn::Connection, dialect::Dialect, registry::CodecRegistry,
          query::Query{T}, params::NamedTuple = NamedTuple()) -&gt; T</code></pre><p>Execute a query and fetch exactly one row.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Database connection</li><li><code>dialect</code>: SQL dialect for compilation</li><li><code>registry</code>: Codec registry for type conversion</li><li><code>query</code>: Query AST to execute</li><li><code>params</code>: Named parameters for the query (default: empty NamedTuple)</li></ul><p><strong>Returns</strong></p><p>Single result of type T</p><p><strong>Errors</strong></p><ul><li>Throws an error if the query returns zero rows</li><li>Throws an error if the query returns more than one row</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:users) |&gt;
    where(col(:users, :id) == param(Int, :id)) |&gt;
    select(NamedTuple, col(:users, :id), col(:users, :email))

user = fetch_one(db, dialect, registry, q, (id = 1,))
# → NamedTuple (exactly one row)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/execute.jl#L247-L280">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.fetch_maybe"><a class="docstring-binding" href="#SQLSketch.Core.fetch_maybe"><code>SQLSketch.Core.fetch_maybe</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fetch_maybe(conn::Connection, dialect::Dialect, registry::CodecRegistry,
            query::Query{T}, params::NamedTuple = NamedTuple()) -&gt; Union{T, Nothing}</code></pre><p>Execute a query and fetch zero or one row.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Database connection</li><li><code>dialect</code>: SQL dialect for compilation</li><li><code>registry</code>: Codec registry for type conversion</li><li><code>query</code>: Query AST to execute</li><li><code>params</code>: Named parameters for the query (default: empty NamedTuple)</li></ul><p><strong>Returns</strong></p><ul><li>Single result of type T if exactly one row is returned</li><li><code>Nothing</code> if zero rows are returned</li></ul><p><strong>Errors</strong></p><p>Throws an error if the query returns more than one row</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:users) |&gt;
    where(col(:users, :email) == param(String, :email)) |&gt;
    select(NamedTuple, col(:users, :id), col(:users, :email))

user = fetch_maybe(db, dialect, registry, q, (email = &quot;test@example.com&quot;,))
# → NamedTuple or Nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/execute.jl#L314-L347">source</a></section></details></article><p><strong>Performance characteristics (PostgreSQL):</strong></p><table><tr><th style="text-align: right">Result Size</th><th style="text-align: right">Time</th><th style="text-align: right">Overhead vs Raw LibPQ</th></tr><tr><td style="text-align: right">500 rows</td><td style="text-align: right">~327 μs</td><td style="text-align: right">40%</td></tr><tr><td style="text-align: right">1667 rows</td><td style="text-align: right">~2.5 ms</td><td style="text-align: right">155%</td></tr></table><p><strong>When to use:</strong></p><ul><li>✅ CRUD operations (iterate over individual records)</li><li>✅ Small to medium result sets (&lt;10,000 rows)</li><li>✅ Row-by-row processing is natural</li></ul><h4 id="Columnar-API-(PostgreSQL-Only)"><a class="docs-heading-anchor" href="#Columnar-API-(PostgreSQL-Only)">Columnar API (PostgreSQL Only)</a><a id="Columnar-API-(PostgreSQL-Only)-1"></a><a class="docs-heading-anchor-permalink" href="#Columnar-API-(PostgreSQL-Only)" title="Permalink"></a></h4><p><strong>Note:</strong> <code>fetch_all_columnar</code> is a PostgreSQL-specific optimization. See PostgreSQL driver documentation for details.</p><p><strong>Performance characteristics (PostgreSQL):</strong></p><table><tr><th style="text-align: right">Result Size</th><th style="text-align: right">Time</th><th style="text-align: right">Overhead vs Raw LibPQ</th></tr><tr><td style="text-align: right">500 rows</td><td style="text-align: right">~252 μs</td><td style="text-align: right">12%</td></tr><tr><td style="text-align: right">1667 rows</td><td style="text-align: right">~1.1 ms</td><td style="text-align: right">6%</td></tr></table><p><strong>Speedup vs row-based:</strong> 8-10x faster</p><p><strong>When to use:</strong></p><ul><li>✅ Analytics queries (aggregations, statistics)</li><li>✅ Large result sets (&gt;1,000 rows)</li><li>✅ Column-wise operations (sum, mean, filter)</li><li>✅ DataFrame/CSV export</li><li>✅ Data science workflows</li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia hljs"># Option 1: NamedTuple of Vectors (flexible)
result = fetch_all_columnar(conn, dialect, registry, query)
# → (id = [1, 2, 3, ...], amount = [100.0, 200.0, ...])
total = sum(result.amount)

# Option 2: Type-safe columnar struct (recommended for production)
struct SalesColumnar
    id::Vector{Int}
    amount::Vector{Float64}
end

result = fetch_all_columnar(conn, dialect, registry, query, SalesColumnar)
# → SalesColumnar([1, 2, 3, ...], [100.0, 200.0, ...])
total = sum(result.amount)  # Type-safe!</code></pre><h3 id="Executing-Statements"><a class="docs-heading-anchor" href="#Executing-Statements">Executing Statements</a><a id="Executing-Statements-1"></a><a class="docs-heading-anchor-permalink" href="#Executing-Statements" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.execute"><a class="docstring-binding" href="#SQLSketch.Core.execute"><code>SQLSketch.Core.execute</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">execute(conn::Connection, dialect::Dialect, query::Query,
        params::NamedTuple = NamedTuple()) -&gt; ExecResult</code></pre><p>Unified API for executing DML statements (INSERT, UPDATE, DELETE) with side effects.</p><p>This is the recommended API for all DML execution. Dispatches internally to <code>execute_dml</code>.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Database connection</li><li><code>dialect</code>: SQL dialect for compilation</li><li><code>query</code>: DML query AST</li><li><code>params</code>: Named parameters for the query (default: empty NamedTuple)</li></ul><p><strong>Returns</strong></p><p>ExecResult containing:</p><ul><li><code>command_type::Symbol</code>: Type of command executed (:insert, :update, :delete)</li><li><code>rowcount::Union{Int, Nothing}</code>: Number of rows affected (currently Nothing)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># INSERT
q = insert_into(:users, [:name, :email]) |&gt;
    values([[literal(&quot;Alice&quot;), literal(&quot;alice@example.com&quot;)]])
result = execute(conn, dialect, q)
# -&gt; ExecResult(:insert, nothing)

# UPDATE
q = update(:users) |&gt;
    set(:status =&gt; literal(&quot;inactive&quot;)) |&gt;
    where(col(:users, :age) &gt; literal(100))
result = execute(conn, dialect, q)
# -&gt; ExecResult(:update, nothing)

# DELETE
q = delete_from(:users) |&gt;
    where(col(:users, :status) == literal(&quot;deleted&quot;))
result = execute(conn, dialect, q)
# -&gt; ExecResult(:delete, nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/execute.jl#L537-L581">source</a></section><section><div><pre><code class="language-julia hljs">execute(conn::Connection, dialect::Dialect, ddl::DDLStatement) -&gt; ExecResult</code></pre><p>Unified API for executing DDL statements (CREATE TABLE, DROP TABLE, etc.) with side effects.</p><p>This is the recommended API for all DDL execution. Dispatches internally to <code>execute_ddl</code>.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Database connection</li><li><code>dialect</code>: SQL dialect for compilation</li><li><code>ddl</code>: DDL statement AST</li></ul><p><strong>Returns</strong></p><p>ExecResult containing:</p><ul><li><code>command_type::Symbol</code>: Type of command executed (:create<em>table, :drop</em>table, etc.)</li><li><code>rowcount::Union{Int, Nothing}</code>: Always nothing for DDL</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># CREATE TABLE
ddl = create_table(:users) |&gt;
      add_column(:id, :integer; primary_key = true) |&gt;
      add_column(:name, :text; nullable = false)
result = execute(conn, dialect, ddl)
# -&gt; ExecResult(:create_table, nothing)

# DROP TABLE
ddl = drop_table(:users; if_exists = true)
result = execute(conn, dialect, ddl)
# -&gt; ExecResult(:drop_table, nothing)

# CREATE INDEX
ddl = create_index(:idx_users_email) |&gt; on(:users, :email)
result = execute(conn, dialect, ddl)
# -&gt; ExecResult(:create_index, nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/ddl.jl#L1614-L1654">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.ExecResult"><a class="docstring-binding" href="#SQLSketch.Core.ExecResult"><code>SQLSketch.Core.ExecResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ExecResult</code></pre><p>Result of executing a statement with side effects (DML/DDL).</p><p><strong>Fields</strong></p><ul><li><code>command_type::Symbol</code>: Type of command executed (:insert, :update, :delete, :create<em>table, :drop</em>table, :alter<em>table, :create</em>index, :drop_index, :unknown)</li><li><code>rowcount::Union{Int, Nothing}</code>: Number of rows affected (Nothing if unknown or not applicable)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">result = execute(conn, dialect, insert_query, params)
println(result.command_type)  # :insert
println(result.rowcount)      # Nothing (currently not implemented)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/execute.jl#L56-L73">source</a></section></details></article><h3 id="Transactions"><a class="docs-heading-anchor" href="#Transactions">Transactions</a><a id="Transactions-1"></a><a class="docs-heading-anchor-permalink" href="#Transactions" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.transaction"><a class="docstring-binding" href="#SQLSketch.Core.transaction"><code>SQLSketch.Core.transaction</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">transaction(f::Function, conn::SQLiteConnection) -&gt; result</code></pre><p>Execute a function within a SQLite transaction.</p><p>Uses BEGIN TRANSACTION / COMMIT / ROLLBACK commands.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Function to execute. Receives SQLiteTransaction handle as argument.</li><li><code>conn</code>: SQLite database connection</li></ul><p><strong>Returns</strong></p><p>The return value of the function <code>f</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">result = transaction(db) do tx
    execute(tx, &quot;INSERT INTO users (email) VALUES (?)&quot;, [&quot;alice@example.com&quot;])
    execute(tx, &quot;INSERT INTO orders (user_id, total) VALUES (?, ?)&quot;, [1, 100.0])
    return &quot;success&quot;
end</code></pre><p><strong>Implementation Details</strong></p><ul><li>BEGIN TRANSACTION starts the transaction</li><li>COMMIT is executed if the function completes successfully</li><li>ROLLBACK is executed if an exception occurs</li><li>The transaction handle can be used with execute() and all query execution APIs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Drivers/sqlite.jl#L413-L445">source</a></section><section><div><pre><code class="language-julia hljs">transaction(f::Function, conn::PostgreSQLConnection) -&gt; result</code></pre><p>Execute a function within a PostgreSQL transaction.</p><p>Uses BEGIN / COMMIT / ROLLBACK commands.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Function to execute. Receives PostgreSQLTransaction handle as argument.</li><li><code>conn</code>: PostgreSQL database connection</li></ul><p><strong>Returns</strong></p><p>The return value of the function <code>f</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">result = transaction(db) do tx
    execute(tx, &quot;INSERT INTO users (email) VALUES ($1)&quot;, [&quot;alice@example.com&quot;])
    execute(tx, &quot;INSERT INTO orders (user_id, total) VALUES ($1, $2)&quot;, [1, 100.0])
    return &quot;success&quot;
end</code></pre><p><strong>Implementation Details</strong></p><ul><li>BEGIN starts the transaction</li><li>COMMIT is executed if the function completes successfully</li><li>ROLLBACK is executed if an exception occurs</li><li>The transaction handle can be used with execute() and all query execution APIs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Drivers/postgresql.jl#L496-L528">source</a></section><section><div><pre><code class="language-julia hljs">transaction(f::Function, conn::MySQLConnection; isolation_level=nothing)</code></pre><p>Execute a function within a transaction.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Function to execute (takes TransactionHandle as argument)</li><li><code>conn</code>: Database connection</li><li><code>isolation_level</code>: Optional isolation level (:read<em>uncommitted, :read</em>committed, :repeatable_read, :serializable)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">transaction(db) do txn
    execute_sql(txn, &quot;INSERT INTO users (email) VALUES (?)&quot;, [&quot;alice@example.com&quot;])
    execute_sql(txn, &quot;INSERT INTO logs (action) VALUES (?)&quot;, [&quot;user_created&quot;])
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Drivers/mysql.jl#L462-L482">source</a></section><section><div><pre><code class="language-julia hljs">transaction(f::Function, conn::Connection) -&gt; result</code></pre><p>Execute a function within a database transaction.</p><p>The transaction automatically commits if the function completes successfully, or rolls back if an exception is thrown.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Function to execute within the transaction. Receives transaction handle as argument.</li><li><code>conn</code>: Database connection</li></ul><p><strong>Returns</strong></p><p>The return value of the function <code>f</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Simple transaction
result = transaction(db) do tx
    execute(tx, &quot;INSERT INTO users (email) VALUES (?)&quot;, [&quot;alice@example.com&quot;])
    execute(tx, &quot;INSERT INTO orders (user_id, total) VALUES (?, ?)&quot;, [1, 100.0])
    return &quot;success&quot;
end
# result == &quot;success&quot;

# Transaction with query execution
users = transaction(db) do tx
    q = from(:users) |&gt;
        where(col(:users, :active) == literal(true)) |&gt;
        select(NamedTuple, col(:users, :id), col(:users, :email))

    fetch_all(tx, dialect, registry, q)
end
# users is Vector{NamedTuple}

# Transaction rollback on exception
try
    transaction(db) do tx
        execute(tx, &quot;INSERT INTO users (email) VALUES (?)&quot;, [&quot;alice@example.com&quot;])
        error(&quot;Something went wrong!&quot;)
        # Transaction is automatically rolled back
    end
catch e
    println(&quot;Transaction rolled back: &quot;, e)
end</code></pre><p><strong>Errors</strong></p><p>Rethrows any exception that occurs within the function <code>f</code> after rolling back the transaction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/transaction.jl#L57-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.savepoint"><a class="docstring-binding" href="#SQLSketch.Core.savepoint"><code>SQLSketch.Core.savepoint</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">savepoint(f::Function, tx::SQLiteTransaction, name::Symbol) -&gt; result</code></pre><p>Create a savepoint within a SQLite transaction for nested transaction semantics.</p><p>Uses SAVEPOINT / RELEASE / ROLLBACK TO commands.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Function to execute within the savepoint. Receives transaction handle.</li><li><code>tx</code>: SQLite transaction handle</li><li><code>name</code>: Unique name for the savepoint</li></ul><p><strong>Returns</strong></p><p>The return value of the function <code>f</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">transaction(db) do tx
    execute_sql(tx, &quot;INSERT INTO users (email) VALUES (?)&quot;, [&quot;alice@example.com&quot;])

    savepoint(tx, :sp1) do sp
        execute_sql(sp, &quot;INSERT INTO orders (user_id, total) VALUES (?, ?)&quot;, [1, 100.0])
        # Rolls back to sp1 if error occurs
    end
end</code></pre><p><strong>Implementation Details</strong></p><ul><li>SAVEPOINT creates a new savepoint on the transaction stack</li><li>RELEASE removes the savepoint on success</li><li>ROLLBACK TO restores database state to the savepoint, then RELEASE removes it</li><li>Savepoints can be nested</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Drivers/sqlite.jl#L512-L548">source</a></section><section><div><pre><code class="language-julia hljs">savepoint(f::Function, tx::PostgreSQLTransaction, name::Symbol) -&gt; result</code></pre><p>Create a savepoint within a PostgreSQL transaction.</p><p>Uses SAVEPOINT / RELEASE / ROLLBACK TO commands.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Function to execute within the savepoint</li><li><code>tx</code>: PostgreSQL transaction handle</li><li><code>name</code>: Unique name for the savepoint</li></ul><p><strong>Returns</strong></p><p>The return value of the function <code>f</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">transaction(db) do tx
    execute_sql(tx, &quot;INSERT INTO users (email) VALUES ($1)&quot;, [&quot;alice@example.com&quot;])

    savepoint(tx, :sp1) do sp
        execute_sql(sp, &quot;INSERT INTO orders (user_id, total) VALUES ($1, $2)&quot;, [1, 100.0])
        # Rolls back to sp1 if error occurs
    end
end</code></pre><p><strong>Implementation Details</strong></p><ul><li>SAVEPOINT creates a new savepoint on the transaction stack</li><li>RELEASE removes the savepoint on success</li><li>ROLLBACK TO restores database state to the savepoint</li><li>Savepoints can be nested</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Drivers/postgresql.jl#L594-L630">source</a></section><section><div><pre><code class="language-julia hljs">savepoint(f::Function, conn::MySQLConnection, name::Symbol)</code></pre><p>Execute a function within a savepoint (nested transaction).</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Function to execute</li><li><code>conn</code>: Database connection (or transaction handle)</li><li><code>name</code>: Savepoint name</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">transaction(db) do txn
    execute_sql(txn, &quot;INSERT INTO users (email) VALUES (?)&quot;, [&quot;alice@example.com&quot;])

    savepoint(txn, :create_log) do sp
        execute_sql(sp, &quot;INSERT INTO logs (action) VALUES (?)&quot;, [&quot;user_created&quot;])
        # This will be rolled back
        error(&quot;Something went wrong!&quot;)
    end

    # Transaction continues despite savepoint rollback
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Drivers/mysql.jl#L523-L549">source</a></section><section><div><pre><code class="language-julia hljs">savepoint(f::Function, tx::TransactionHandle, name::Symbol) -&gt; result</code></pre><p>Create a savepoint within a transaction for nested transaction semantics.</p><p>Savepoints allow partial rollback: if an exception occurs within the savepoint, only changes made within that savepoint are rolled back. The outer transaction can still commit.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Function to execute within the savepoint. Receives transaction handle.</li><li><code>tx</code>: Transaction handle (from outer <code>transaction()</code> call)</li><li><code>name</code>: Unique name for the savepoint</li></ul><p><strong>Returns</strong></p><p>The return value of the function <code>f</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">transaction(db) do tx
    # This insert is in the outer transaction
    execute(tx, &quot;INSERT INTO users (email) VALUES (?)&quot;, [&quot;alice@example.com&quot;])

    # Savepoint for risky operation
    try
        savepoint(tx, :risky_operation) do sp
            execute(sp, &quot;INSERT INTO orders (user_id, total) VALUES (?, ?)&quot;, [1, 100.0])
            # Some risky operation that might fail
            if some_condition
                error(&quot;Risky operation failed!&quot;)
            end
        end
    catch e
        # Orders insert was rolled back, but users insert will still commit
        println(&quot;Savepoint rolled back: &quot;, e)
    end

    # User insert still commits
end

# Multiple savepoints
transaction(db) do tx
    execute(tx, &quot;INSERT INTO users (email) VALUES (?)&quot;, [&quot;alice@example.com&quot;])

    savepoint(tx, :sp1) do sp1
        execute(sp1, &quot;INSERT INTO orders (user_id, total) VALUES (?, ?)&quot;, [1, 100.0])

        savepoint(sp1, :sp2) do sp2
            execute(sp2, &quot;INSERT INTO order_items (order_id, sku) VALUES (?, ?)&quot;,
                    [1, &quot;ABC123&quot;])
        end
    end
end</code></pre><p><strong>Errors</strong></p><p>Rethrows any exception that occurs within the function <code>f</code> after rolling back to the savepoint.</p><p><strong>Notes</strong></p><ul><li>Savepoints can be nested</li><li>Savepoint names must be unique within a transaction</li><li>SQLite uses SAVEPOINT/RELEASE/ROLLBACK TO commands</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/transaction.jl#L116-L184">source</a></section></details></article><h2 id="SQL-Generation"><a class="docs-heading-anchor" href="#SQL-Generation">SQL Generation</a><a id="SQL-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#SQL-Generation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SQLSketch.Core.sql"><a class="docstring-binding" href="#SQLSketch.Core.sql"><code>SQLSketch.Core.sql</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sql(dialect::Dialect, query::Query) -&gt; String</code></pre><p>Generate SQL string from a query for inspection (without executing).</p><p><strong>Arguments</strong></p><ul><li><code>dialect</code>: SQL dialect for compilation</li><li><code>query</code>: Query AST to compile</li></ul><p><strong>Returns</strong></p><p>SQL string (with parameter placeholders)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:users) |&gt;
    where(col(:users, :age) &gt; param(Int, :min_age)) |&gt;
    select(NamedTuple, col(:users, :name))

sql_str = sql(dialect, q)
# → &quot;SELECT `name` FROM `users` WHERE `age` &gt; ?&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/execute.jl#L381-L405">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.compile"><a class="docstring-binding" href="#SQLSketch.Core.compile"><code>SQLSketch.Core.compile</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compile(dialect::Dialect, query::Query) -&gt; (sql::String, params::Vector{Symbol})</code></pre><p>Compile a Query AST into a SQL string and parameter list.</p><p><strong>Arguments</strong></p><ul><li><code>dialect</code>: The SQL dialect to use for compilation</li><li><code>query</code>: The query AST to compile</li></ul><p><strong>Returns</strong></p><ul><li><code>sql</code>: The generated SQL string</li><li><code>params</code>: A vector of parameter names in the order they appear in the SQL</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:users) |&gt; where(col(:users, :id) == param(Int, :user_id))
sql, params = compile(SQLiteDialect(), q)
# sql    → &quot;SELECT * FROM `users` WHERE `users`.`id` = ?&quot;
# params → [:user_id]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/dialect.jl#L82-L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.explain"><a class="docstring-binding" href="#SQLSketch.Core.explain"><code>SQLSketch.Core.explain</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">explain(conn::Connection, dialect::Dialect, query::Query) -&gt; String</code></pre><p>Execute EXPLAIN on a query and return the query plan.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Database connection</li><li><code>dialect</code>: SQL dialect for compilation</li><li><code>query</code>: Query AST to explain</li></ul><p><strong>Returns</strong></p><p>EXPLAIN output as a string</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">q = from(:users) |&gt;
    where(col(:users, :age) &gt; literal(25)) |&gt;
    select(NamedTuple, col(:users, :name))

plan = explain(db, dialect, q)
# → EXPLAIN output</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/execute.jl#L411-L436">source</a></section></details></article><h2 id="Metadata-API"><a class="docs-heading-anchor" href="#Metadata-API">Metadata API</a><a id="Metadata-API-1"></a><a class="docs-heading-anchor-permalink" href="#Metadata-API" title="Permalink"></a></h2><p>SQLSketch provides introspection APIs to query database schema metadata:</p><h3 id="Database-Schema-Inspection"><a class="docs-heading-anchor" href="#Database-Schema-Inspection">Database Schema Inspection</a><a id="Database-Schema-Inspection-1"></a><a class="docs-heading-anchor-permalink" href="#Database-Schema-Inspection" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.list_tables"><a class="docstring-binding" href="#SQLSketch.Core.list_tables"><code>SQLSketch.Core.list_tables</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">list_tables(conn::SQLiteConnection) -&gt; Vector{String}</code></pre><p>List all tables in the SQLite database.</p><p>Queries the <code>sqlite_master</code> system table.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Active SQLite connection</li></ul><p><strong>Returns</strong></p><p>Vector of table names (excluding SQLite internal tables like sqlite_sequence)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">conn = connect(SQLiteDriver(), &quot;mydb.sqlite&quot;)
tables = list_tables(conn)
# → [&quot;users&quot;, &quot;posts&quot;, &quot;comments&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Drivers/sqlite.jl#L269-L291">source</a></section><section><div><pre><code class="language-julia hljs">list_tables(conn::PostgreSQLConnection; schema::String=&quot;public&quot;) -&gt; Vector{String}</code></pre><p>List all tables in a PostgreSQL database schema.</p><p>Queries the <code>information_schema.tables</code> catalog.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Active PostgreSQL connection</li><li><code>schema</code>: Schema name (default: &quot;public&quot;)</li></ul><p><strong>Returns</strong></p><p>Vector of table names in the specified schema</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">conn = connect(PostgreSQLDriver(), &quot;postgresql://localhost/mydb&quot;)
tables = list_tables(conn)
# → [&quot;users&quot;, &quot;posts&quot;, &quot;comments&quot;]

# List tables in specific schema
tables = list_tables(conn; schema = &quot;analytics&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Drivers/postgresql.jl#L317-L343">source</a></section><section><div><pre><code class="language-julia hljs">list_tables(conn::MySQLConnection; schema::Union{String,Nothing}=nothing) -&gt; Vector{String}</code></pre><p>List all tables in the database or schema.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Active connection</li><li><code>schema</code>: Optional schema name (default: current database)</li></ul><p><strong>Returns</strong></p><p>Vector of table names sorted alphabetically</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># List tables in current database
tables = list_tables(db)
# → [&quot;comments&quot;, &quot;posts&quot;, &quot;users&quot;]

# List tables in specific database
tables = list_tables(db; schema = &quot;mydb&quot;)
# → [&quot;orders&quot;, &quot;products&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Drivers/mysql.jl#L573-L598">source</a></section><section><div><pre><code class="language-julia hljs">list_tables(conn::Connection) -&gt; Vector{String}</code></pre><p>List all tables in the database.</p><p>Returns a vector of table names as strings.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Active database connection</li></ul><p><strong>Returns</strong></p><p>Vector of table names (strings)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">conn = connect(SQLiteDriver(), &quot;mydb.sqlite&quot;)
tables = list_tables(conn)
# → [&quot;users&quot;, &quot;posts&quot;, &quot;comments&quot;]</code></pre><p><strong>Implementation</strong></p><p>This function must be implemented by each driver. The default implementation throws an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/metadata.jl#L82-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.list_schemas"><a class="docstring-binding" href="#SQLSketch.Core.list_schemas"><code>SQLSketch.Core.list_schemas</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">list_schemas(conn::SQLiteConnection) -&gt; Vector{String}</code></pre><p>List schemas in SQLite.</p><p>SQLite does not have schemas in the same sense as PostgreSQL. Returns a single default schema name for compatibility.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Active SQLite connection</li></ul><p><strong>Returns</strong></p><p>Vector with single element [&quot;main&quot;]</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">conn = connect(SQLiteDriver(), &quot;mydb.sqlite&quot;)
schemas = list_schemas(conn)
# → [&quot;main&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Drivers/sqlite.jl#L363-L386">source</a></section><section><div><pre><code class="language-julia hljs">list_schemas(conn::PostgreSQLConnection) -&gt; Vector{String}</code></pre><p>List all schemas in a PostgreSQL database.</p><p>Queries <code>information_schema.schemata</code>, excluding system schemas.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Active PostgreSQL connection</li></ul><p><strong>Returns</strong></p><p>Vector of schema names (excluding pg<em>* and information</em>schema)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">conn = connect(PostgreSQLDriver(), &quot;postgresql://localhost/mydb&quot;)
schemas = list_schemas(conn)
# → [&quot;public&quot;, &quot;myapp&quot;, &quot;analytics&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Drivers/postgresql.jl#L435-L457">source</a></section><section><div><pre><code class="language-julia hljs">list_schemas(conn::MySQLConnection) -&gt; Vector{String}</code></pre><p>List all schemas (databases) accessible to the current user.</p><p>Excludes system schemas (<code>information_schema</code>, <code>mysql</code>, <code>performance_schema</code>, <code>sys</code>).</p><p><strong>Returns</strong></p><p>Vector of schema names sorted alphabetically</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">schemas = list_schemas(db)
# → [&quot;mydb&quot;, &quot;test&quot;, &quot;warehouse&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Drivers/mysql.jl#L725-L742">source</a></section><section><div><pre><code class="language-julia hljs">list_schemas(conn::Connection) -&gt; Vector{String}</code></pre><p>List all schemas in the database.</p><p>Note: This is primarily for PostgreSQL. SQLite does not have schemas, and MySQL uses &quot;databases&quot; instead of schemas.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Active database connection</li></ul><p><strong>Returns</strong></p><p>Vector of schema names (strings)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">conn = connect(PostgreSQLDriver(), &quot;postgresql://localhost/mydb&quot;)
schemas = list_schemas(conn)
# → [&quot;public&quot;, &quot;myapp&quot;, &quot;analytics&quot;]</code></pre><p><strong>Implementation</strong></p><p>This function must be implemented by each driver. Drivers for databases without schema support (e.g., SQLite) should return an empty vector or a single default schema name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/metadata.jl#L149-L178">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.describe_table"><a class="docstring-binding" href="#SQLSketch.Core.describe_table"><code>SQLSketch.Core.describe_table</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">describe_table(conn::SQLiteConnection, table::Symbol) -&gt; Vector{ColumnInfo}</code></pre><p>Describe the structure of a SQLite table.</p><p>Uses <code>PRAGMA table_info</code> to get column information.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Active SQLite connection</li><li><code>table</code>: Table name as a symbol</li></ul><p><strong>Returns</strong></p><p>Vector of <code>ColumnInfo</code> structs describing each column</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">conn = connect(SQLiteDriver(), &quot;mydb.sqlite&quot;)
columns = describe_table(conn, :users)
for col in columns
    println(&quot;$(col.name): $(col.type)&quot;)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Drivers/sqlite.jl#L310-L335">source</a></section><section><div><pre><code class="language-julia hljs">describe_table(conn::PostgreSQLConnection, table::Symbol;
               schema::String=&quot;public&quot;) -&gt; Vector{ColumnInfo}</code></pre><p>Describe the structure of a PostgreSQL table.</p><p>Queries <code>information_schema.columns</code> and <code>information_schema.key_column_usage</code>.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Active PostgreSQL connection</li><li><code>table</code>: Table name as a symbol</li><li><code>schema</code>: Schema name (default: &quot;public&quot;)</li></ul><p><strong>Returns</strong></p><p>Vector of <code>ColumnInfo</code> structs describing each column</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">conn = connect(PostgreSQLDriver(), &quot;postgresql://localhost/mydb&quot;)
columns = describe_table(conn, :users)
for col in columns
    println(&quot;$(col.name): $(col.type)&quot;)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Drivers/postgresql.jl#L363-L390">source</a></section><section><div><pre><code class="language-julia hljs">describe_table(conn::MySQLConnection, table::Symbol;
               schema::Union{String,Nothing}=nothing) -&gt; Vector{ColumnInfo}</code></pre><p>Get column information for a table.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Active connection</li><li><code>table</code>: Table name as Symbol</li><li><code>schema</code>: Optional schema name (default: current database)</li></ul><p><strong>Returns</strong></p><p>Vector of ColumnInfo structs with column metadata</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">columns = describe_table(db, :users)
for col in columns
    println(&quot;$(col.name): $(col.type)&quot;)
end

# Specific schema
columns = describe_table(db, :orders; schema = &quot;sales&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Drivers/mysql.jl#L634-L661">source</a></section><section><div><pre><code class="language-julia hljs">describe_table(conn::Connection, table::Symbol) -&gt; Vector{ColumnInfo}</code></pre><p>Describe the structure of a table.</p><p>Returns information about all columns in the specified table.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Active database connection</li><li><code>table</code>: Table name as a symbol</li></ul><p><strong>Returns</strong></p><p>Vector of <code>ColumnInfo</code> structs describing each column</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">conn = connect(SQLiteDriver(), &quot;mydb.sqlite&quot;)
columns = describe_table(conn, :users)
for col in columns
    println(&quot;$(col.name): $(col.type)&quot;)
end</code></pre><p><strong>Implementation</strong></p><p>This function must be implemented by each driver. The default implementation throws an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/metadata.jl#L114-L144">source</a></section></details></article><p><strong>Example:</strong></p><pre><code class="language-julia hljs"># List all tables in current database
tables = list_tables(conn)
# → [&quot;orders&quot;, &quot;products&quot;, &quot;users&quot;]

# Get table structure
columns = describe_table(conn, :users)
for col in columns
    println(&quot;$(col.name): $(col.type) $(col.nullable ? &quot;NULL&quot; : &quot;NOT NULL&quot;)&quot;)
end
# → id: INT NOT NULL [PK]
# → email: VARCHAR(255) NOT NULL
# → name: VARCHAR(255) NOT NULL
# → age: INT NULL
# → created_at: DATETIME NULL

# List all schemas/databases
schemas = list_schemas(conn)
# → [&quot;myapp_dev&quot;, &quot;myapp_test&quot;, &quot;myapp_prod&quot;]</code></pre><p><strong>MySQL-specific notes:</strong></p><ul><li><code>list_tables()</code> excludes system tables automatically</li><li><code>list_schemas()</code> excludes <code>information_schema</code>, <code>mysql</code>, <code>performance_schema</code>, <code>sys</code></li><li><code>describe_table()</code> returns MySQL-specific type names (e.g., <code>TINYINT(1)</code>, <code>VARCHAR(255)</code>)</li></ul><h2 id="Dialects"><a class="docs-heading-anchor" href="#Dialects">Dialects</a><a id="Dialects-1"></a><a class="docs-heading-anchor-permalink" href="#Dialects" title="Permalink"></a></h2><p>SQLSketch provides dialect abstraction for different SQL databases:</p><ul><li><strong>SQLiteDialect</strong> - SQLite SQL generation</li><li><strong>PostgreSQLDialect</strong> - PostgreSQL SQL generation</li><li><strong>MySQLDialect</strong> - MySQL SQL generation</li></ul><p>Each dialect handles:</p><ul><li>Identifier quoting (<code>&quot;identifier&quot;</code> for PostgreSQL, <span>$`identifier`$</span> for MySQL/SQLite)</li><li>Placeholder syntax (<code>$1, $2, ...</code> for PostgreSQL, <code>?</code> for MySQL/SQLite)</li><li>Type mapping and casting</li><li>SQL feature capabilities (RETURNING, ON CONFLICT, etc.)</li></ul><p><strong>Note:</strong> MariaDB may work with MySQLDialect via protocol compatibility but is not explicitly tested.</p><h2 id="Drivers"><a class="docs-heading-anchor" href="#Drivers">Drivers</a><a id="Drivers-1"></a><a class="docs-heading-anchor-permalink" href="#Drivers" title="Permalink"></a></h2><p>SQLSketch provides driver abstraction for database connections:</p><ul><li><strong>SQLiteDriver</strong> - SQLite database driver (in-memory or file-based)</li><li><strong>PostgreSQLDriver</strong> - PostgreSQL database driver (via LibPQ.jl)</li><li><strong>MySQLDriver</strong> - MySQL database driver (via MySQL.jl, tested with MySQL 8.0+)</li></ul><p>Each driver handles:</p><ul><li>Connection management</li><li>Query execution</li><li>Transaction support</li><li>Parameter binding</li><li>Result mapping</li><li>Prepared statement caching (MySQL, PostgreSQL)</li></ul><h3 id="MySQL-Driver-Features"><a class="docs-heading-anchor" href="#MySQL-Driver-Features">MySQL Driver Features</a><a id="MySQL-Driver-Features-1"></a><a class="docs-heading-anchor-permalink" href="#MySQL-Driver-Features" title="Permalink"></a></h3><p><strong>JSON Support:</strong></p><p>MySQL 5.7+ provides native JSON type support via the <code>JSONCodec</code>:</p><pre><code class="language-julia hljs">using SQLSketch.Codecs.MySQL

# Register MySQL codecs (includes JSON support)
registry = CodecRegistry()
MySQL.register_mysql_codecs!(registry)

# JSON data is automatically encoded/decoded
metadata = Dict(&quot;role&quot; =&gt; &quot;admin&quot;, &quot;permissions&quot; =&gt; [&quot;read&quot;, &quot;write&quot;])
execute_sql(conn, &quot;INSERT INTO users (email, metadata) VALUES (?, ?)&quot;,
           [&quot;user@example.com&quot;, JSON3.write(metadata)])

# Retrieve JSON
rows = fetch_all(conn, dialect, registry, query)
json_data = JSON3.read(rows[1].metadata, Dict{String, Any})</code></pre><p><strong>Prepared Statement Caching:</strong></p><p>MySQL driver includes LRU-based prepared statement caching for improved performance:</p><pre><code class="language-julia hljs"># Prepared statements are automatically cached
q = from(:users) |&gt;
    where(col(:users, :id) == param(Int, :id)) |&gt;
    select(NamedTuple, col(:users, :email))

# First execution - cache miss, statement prepared
result1 = fetch_all(conn, dialect, registry, q, (id=1,); use_prepared=true)

# Second execution - cache hit, reuses prepared statement
result2 = fetch_all(conn, dialect, registry, q, (id=2,); use_prepared=true)</code></pre><p><strong>Performance benefits:</strong></p><ul><li>10-20% faster for repeated queries</li><li>Reduced MySQL server load (no re-parsing)</li><li>LRU eviction prevents memory bloat</li><li>Thread-safe for single-connection use</li></ul><p><strong>Configuration:</strong></p><pre><code class="language-julia hljs"># Custom cache size
raw_conn = DBInterface.connect(MySQL.Connection, host, user, password; db=db)
conn = MySQLConnection(raw_conn; cache_size=200, enable_cache=true)

# Disable caching
conn = MySQLConnection(raw_conn; enable_cache=false)</code></pre><h2 id="Migration-System"><a class="docs-heading-anchor" href="#Migration-System">Migration System</a><a id="Migration-System-1"></a><a class="docs-heading-anchor-permalink" href="#Migration-System" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SQLSketch.Extras.apply_migrations"><a class="docstring-binding" href="#SQLSketch.Extras.apply_migrations"><code>SQLSketch.Extras.apply_migrations</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">apply_migrations(conn::Connection, dialect::Dialect, migrations_dir::String) -&gt; Vector{Migration}</code></pre><p>Apply all pending migrations from a directory.</p><p>Discovers all migrations in the directory, identifies which have not been applied, and applies them in order (oldest first). Each migration runs in its own transaction.</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Database connection</li><li><code>dialect</code>: SQL dialect</li><li><code>migrations_dir</code>: Path to directory containing migration files</li></ul><p><strong>Returns</strong></p><p>Vector of migrations that were applied (empty if all migrations were already applied)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">applied = apply_migrations(conn, dialect, &quot;db/migrations&quot;)
println(&quot;Applied $(length(applied)) migrations&quot;)</code></pre><p><strong>Errors</strong></p><ul><li>Throws error if migration directory doesn&#39;t exist</li><li>Throws error if any migration fails (already-applied migrations are not rolled back)</li><li>Throws error if applied migration checksum doesn&#39;t match file checksum (modification detected)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Extras/migrations.jl#L486-L516">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Extras.migration_status"><a class="docstring-binding" href="#SQLSketch.Extras.migration_status"><code>SQLSketch.Extras.migration_status</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">migration_status(conn::Connection, dialect::Dialect, migrations_dir::String) -&gt; Vector{MigrationStatus}</code></pre><p>Get the status of all migrations (applied and pending).</p><p><strong>Arguments</strong></p><ul><li><code>conn</code>: Database connection</li><li><code>dialect</code>: SQL dialect</li><li><code>migrations_dir</code>: Path to directory containing migration files</li></ul><p><strong>Returns</strong></p><p>Vector of MigrationStatus structs, sorted by version (oldest first)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">status = migration_status(conn, dialect, &quot;db/migrations&quot;)
for s in status
    applied_str = s.applied ? &quot;✓&quot; : &quot;✗&quot;
    println(&quot;$applied_str $(s.migration.version) $(s.migration.name)&quot;)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Extras/migrations.jl#L551-L575">source</a></section></details></article><h2 id="Connection-Pooling"><a class="docs-heading-anchor" href="#Connection-Pooling">Connection Pooling</a><a id="Connection-Pooling-1"></a><a class="docs-heading-anchor-permalink" href="#Connection-Pooling" title="Permalink"></a></h2><p>SQLSketch provides thread-safe connection pooling for high-concurrency applications.</p><h3 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Create connection pool
pool = ConnectionPool(PostgreSQLDriver(),
                      &quot;postgresql://localhost/mydb&quot;;
                      min_size=2,    # Minimum connections
                      max_size=10)   # Maximum connections

# Resource-safe pattern (recommended)
with_connection(pool) do conn
    result = fetch_all(conn, dialect, registry, query)
end

# Manual acquire/release pattern
conn = acquire(pool)
try
    result = fetch_all(conn, dialect, registry, query)
finally
    release(pool, conn)
end

# Cleanup
close(pool)</code></pre><h3 id="API-Reference-2"><a class="docs-heading-anchor" href="#API-Reference-2">API Reference</a><a class="docs-heading-anchor-permalink" href="#API-Reference-2" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SQLSketch.Core.ConnectionPool"><a class="docstring-binding" href="#SQLSketch.Core.ConnectionPool"><code>SQLSketch.Core.ConnectionPool</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ConnectionPool{D &lt;: Driver, C &lt;: Connection}</code></pre><p>A thread-safe pool of database connections.</p><p>The pool maintains a collection of connections and provides thread-safe acquire/release operations. Connections are validated before reuse and automatically replaced if broken.</p><p><strong>Fields</strong></p><ul><li><code>driver</code>: The database driver for creating connections</li><li><code>config</code>: Driver-specific connection configuration</li><li><code>min_size</code>: Minimum number of connections to maintain</li><li><code>max_size</code>: Maximum number of connections allowed</li><li><code>connections</code>: Vector of pooled connections</li><li><code>lock</code>: ReentrantLock for thread-safe operations</li><li><code>health_check_interval</code>: Seconds between health checks (default: 60.0)</li><li><code>closed</code>: Whether the pool has been closed</li></ul><p><strong>Configuration</strong></p><ul><li><p><code>min_size</code>: Minimum pool size (default: 1)</p><ul><li>Pool will maintain at least this many connections</li><li>Connections created on pool initialization</li></ul></li><li><p><code>max_size</code>: Maximum pool size (default: 10)</p><ul><li>Pool will never create more than this many connections</li><li><code>acquire()</code> blocks if all connections are in use</li></ul></li><li><p><code>health_check_interval</code>: Health check interval in seconds (default: 60.0)</p><ul><li>Connections idle longer than this are validated before reuse</li><li>Set to 0.0 to disable health checking</li></ul></li></ul><p><strong>Thread Safety</strong></p><p>All pool operations (acquire, release, close) are protected by a ReentrantLock. It is safe to use the same pool from multiple threads.</p><p><strong>Performance</strong></p><p>Connection pooling reduces connection overhead by &gt;80% for typical workloads. The overhead of pool management (lock acquisition, health checks) is negligible compared to connection establishment time.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create pool
pool = ConnectionPool(PostgreSQLDriver(),
                      &quot;postgresql://localhost/mydb&quot;;
                      min_size = 2, max_size = 10)

# Use with resource-safe pattern
with_connection(pool) do conn
    # Connection automatically released after block
    result = execute_sql(conn, &quot;SELECT 1&quot;, [])
end

# Close pool when done
close(pool)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/pool.jl#L500-L564">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.acquire"><a class="docstring-binding" href="#SQLSketch.Core.acquire"><code>SQLSketch.Core.acquire</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">acquire(pool::ConnectionPool{D, C}; timeout::Float64 = 30.0) -&gt; C</code></pre><p>Acquire a connection from the pool.</p><p>This function returns an available connection from the pool. If all connections are in use and the pool is not at maximum capacity, a new connection is created. If all connections are in use and the pool is at maximum capacity, this function blocks until a connection becomes available or the timeout is reached.</p><p><strong>Arguments</strong></p><ul><li><code>pool</code>: The connection pool</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>timeout</code>: Maximum time to wait in seconds (default: 30.0). Set to <code>Inf</code> for no timeout.</li></ul><p><strong>Returns</strong></p><p>A Connection instance from the pool</p><p><strong>Blocking Behavior</strong></p><p>If all connections are in use and the pool is at max_size, this function will block (using Condition wait) until a connection is released or timeout is reached.</p><p><strong>Timeout</strong></p><p>If no connection becomes available within <code>timeout</code> seconds, throws an error. This prevents indefinite blocking and helps detect resource leaks early.</p><p><strong>Health Checking</strong></p><p>Before returning a connection, this function checks if the connection needs health validation (based on <code>health_check_interval</code>). If validation fails, the connection is automatically replaced with a new one.</p><p><strong>Thread Safety</strong></p><p>This function is thread-safe and can be called from multiple threads.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># With default 30s timeout
conn = acquire(pool)
try
    result = execute_sql(conn, &quot;SELECT 1&quot;, [])
finally
    release(pool, conn)
end

# With custom timeout
conn = acquire(pool; timeout = 5.0)  # 5 seconds

# No timeout
conn = acquire(pool; timeout = Inf)</code></pre><p><strong>Note</strong></p><p>It is recommended to use <code>with_connection()</code> instead of manual acquire/release to ensure connections are always released, even if an exception occurs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/pool.jl#L678-L742">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.release"><a class="docstring-binding" href="#SQLSketch.Core.release"><code>SQLSketch.Core.release</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">release(pool::ConnectionPool{D, C}, conn::C) -&gt; Nothing</code></pre><p>Release a connection back to the pool.</p><p>This function marks the connection as available for reuse by other callers. The connection is not closed - it remains in the pool for future use.</p><p><strong>Arguments</strong></p><ul><li><code>pool</code>: The connection pool</li><li><code>conn</code>: The connection to release (must have been acquired from this pool)</li></ul><p><strong>Returns</strong></p><p>Nothing</p><p><strong>Thread Safety</strong></p><p>This function is thread-safe and can be called from multiple threads.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">conn = acquire(pool)
try
    result = execute_sql(conn, &quot;SELECT 1&quot;, [])
finally
    release(pool, conn)
end</code></pre><p><strong>Note</strong></p><p>It is recommended to use <code>with_connection()</code> instead of manual acquire/release.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/pool.jl#L901-L936">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SQLSketch.Core.with_connection"><a class="docstring-binding" href="#SQLSketch.Core.with_connection"><code>SQLSketch.Core.with_connection</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">with_connection(f::Function, pool::ConnectionPool{D, C}) -&gt; result</code></pre><p>Execute a function with a connection from the pool.</p><p>This is the recommended way to use connection pools. It ensures that the connection is always released back to the pool, even if an exception occurs.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Function to execute. Receives a Connection as its argument.</li><li><code>pool</code>: The connection pool</li></ul><p><strong>Returns</strong></p><p>The return value of function <code>f</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">pool = ConnectionPool(PostgreSQLDriver(), &quot;postgresql://localhost/mydb&quot;)

result = with_connection(pool) do conn
    execute_sql(conn, &quot;SELECT * FROM users&quot;, [])
end</code></pre><p><strong>Thread Safety</strong></p><p>This function is thread-safe. Multiple threads can call <code>with_connection</code> on the same pool concurrently.</p><p><strong>Exception Handling</strong></p><p>If function <code>f</code> throws an exception, the connection is still released back to the pool before the exception is re-thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/daikichiba9511/SQLSketch.jl/blob/4505c23f7401e390bdd9743057c539bf08897fc8/src/Core/pool.jl#L961-L997">source</a></section></details></article><h3 id="Configuration"><a class="docs-heading-anchor" href="#Configuration">Configuration</a><a id="Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Configuration" title="Permalink"></a></h3><pre><code class="language-julia hljs">pool = ConnectionPool(driver, config;
                      min_size = 1,              # Minimum pool size
                      max_size = 10,             # Maximum pool size
                      health_check_interval = 60.0)  # Health check interval (seconds)</code></pre><p><strong>Parameters:</strong></p><ul><li><code>driver</code>: Database driver instance</li><li><code>config</code>: Driver-specific connection configuration (e.g., connection string for PostgreSQL)</li><li><code>min_size</code>: Minimum number of connections to maintain (default: 1)</li><li><code>max_size</code>: Maximum number of connections allowed (default: 10)</li><li><code>health_check_interval</code>: Seconds between health checks (default: 60.0, set to 0.0 to disable)</li></ul><h3 id="Performance"><a class="docs-heading-anchor" href="#Performance">Performance</a><a id="Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Performance" title="Permalink"></a></h3><p>Connection pooling provides:</p><ul><li><strong>&gt;80% reduction</strong> in connection overhead</li><li><strong>5-10x faster</strong> for short queries (connection time dominates)</li><li><strong>Near-zero overhead</strong> for long queries</li><li><strong>Better resource utilization</strong> under high concurrency</li></ul><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><p><strong>PostgreSQL Connection Pool:</strong></p><pre><code class="language-julia hljs">pool = ConnectionPool(PostgreSQLDriver(),
                      &quot;postgresql://user:pass@localhost/mydb&quot;;
                      min_size=5, max_size=20)

# Use in multi-threaded application
Threads.@threads for i in 1:100
    with_connection(pool) do conn
        result = fetch_all(conn, dialect, registry, query)
        # Process result...
    end
end

close(pool)</code></pre><p><strong>MySQL Connection Pool:</strong></p><pre><code class="language-julia hljs">pool = ConnectionPool(MySQLDriver(),
                      (&quot;localhost&quot;, &quot;mydb&quot;, &quot;user&quot;, &quot;password&quot;);
                      min_size=2, max_size=10)

with_connection(pool) do conn
    result = fetch_all(conn, dialect, registry, query)
end

close(pool)</code></pre><p><strong>SQLite Connection Pool:</strong></p><pre><code class="language-julia hljs"># SQLite supports connection pooling for read-heavy workloads
pool = ConnectionPool(SQLiteDriver(), &quot;:memory:&quot;;
                      min_size=1, max_size=5)

with_connection(pool) do conn
    result = fetch_all(conn, dialect, registry, query)
end

close(pool)</code></pre><h3 id="Thread-Safety"><a class="docs-heading-anchor" href="#Thread-Safety">Thread Safety</a><a id="Thread-Safety-1"></a><a class="docs-heading-anchor-permalink" href="#Thread-Safety" title="Permalink"></a></h3><p>All pool operations (acquire, release, close) are thread-safe and protected by a <code>ReentrantLock</code>. The pool can be safely shared across multiple threads.</p><h3 id="Health-Checking"><a class="docs-heading-anchor" href="#Health-Checking">Health Checking</a><a id="Health-Checking-1"></a><a class="docs-heading-anchor-permalink" href="#Health-Checking" title="Permalink"></a></h3><p>The pool validates connections before reuse:</p><ul><li>Connections idle longer than <code>health_check_interval</code> are health-checked</li><li>Broken connections are automatically replaced</li><li>Health checks use lightweight ping queries</li></ul><h3 id="Best-Practices"><a class="docs-heading-anchor" href="#Best-Practices">Best Practices</a><a id="Best-Practices-1"></a><a class="docs-heading-anchor-permalink" href="#Best-Practices" title="Permalink"></a></h3><ol><li><strong>Use <code>with_connection</code> pattern</strong>: Ensures connections are always released</li><li><strong>Set appropriate pool size</strong>: Too small = contention, too large = wasted resources</li><li><strong>Monitor pool utilization</strong>: Check <code>in_use</code> vs <code>available</code> connections</li><li><strong>Close pool on shutdown</strong>: Use <code>close(pool)</code> to clean up resources</li></ol><p>See <code>examples/connection_pool_example.jl</code> for a complete example.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../design/">Design »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 22 December 2025 05:37">Monday 22 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
